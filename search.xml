<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL概述</title>
    <url>/2022/05/04/SQL%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>SQL（Structured Query Language） 结构化查询语言，是关系数据库的标准语言 </p>
<p>SQL是一个通用的、功能极强的关系数据库语言</p>
<span id="more"></span>

<h2 id="SQL的特点"><a href="#SQL的特点" class="headerlink" title="SQL的特点"></a>SQL的特点</h2><h3 id="综合统一"><a href="#综合统一" class="headerlink" title="综合统一"></a>综合统一</h3><ul>
<li>集数据定义语言（DDL），数据操纵语言（DML）， 数据控制语言（DCL）功能于一体</li>
<li>可以独立完成数据库生命周期中的全部活动</li>
<li>用户数据库投入运行后，可根据需要随时逐步修改模 式，不影响数据库的运行</li>
<li>数据操作符统一</li>
</ul>
<h3 id="高度非过程化"><a href="#高度非过程化" class="headerlink" title="高度非过程化"></a>高度非过程化</h3><ul>
<li>非关系数据模型的数据操纵语言“面向过程”， 必须指定存取路径</li>
<li>SQL只要提出“做什么”，无须了解存取路径</li>
<li>存取路径的选择以及SQL的操作过程由系统自动完成</li>
</ul>
<h3 id="面向集合的操作方式"><a href="#面向集合的操作方式" class="headerlink" title="面向集合的操作方式"></a>面向集合的操作方式</h3><ul>
<li>非关系数据模型采用面向记录的操作方式，操作对象是一条记录</li>
<li>SQL采用集合操作方式</li>
</ul>
<h3 id="以同一种语法结构提供多种使用方式"><a href="#以同一种语法结构提供多种使用方式" class="headerlink" title="以同一种语法结构提供多种使用方式"></a>以同一种语法结构提供多种使用方式</h3><ul>
<li>SQL是独立的语言</li>
<li>SQL又是嵌入式语言</li>
</ul>
<h3 id="语言简洁，易学易用"><a href="#语言简洁，易学易用" class="headerlink" title="语言简洁，易学易用"></a>语言简洁，易学易用</h3><p>完成核心功能只用了9个动词</p>
<table>
<thead>
<tr>
<th>SQL功能</th>
<th>动词</th>
</tr>
</thead>
<tbody><tr>
<td>数据查询</td>
<td>SELECT</td>
</tr>
<tr>
<td>数据定义</td>
<td>CREATA, DROP, ALTER</td>
</tr>
<tr>
<td>数据操纵</td>
<td>INSERT, UPDATE, DELETE</td>
</tr>
<tr>
<td>数据控制</td>
<td>GRANT, REVOKE</td>
</tr>
</tbody></table>
<h2 id="SQL的基本概念"><a href="#SQL的基本概念" class="headerlink" title="SQL的基本概念"></a>SQL的基本概念</h2><img src="image-20220504214052224.png" alt="image-20220504214052224" style="zoom:50%;" />

<h3 id="基本表"><a href="#基本表" class="headerlink" title="基本表"></a>基本表</h3><ul>
<li>本身独立存在的表</li>
<li>SQL中一个关系就对应一个基本表</li>
<li>一个（或多个）基本表对应一个存储文件 </li>
<li>一个表可以带若干索引</li>
</ul>
<h3 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h3><ul>
<li>逻辑结构组成了关系数据库的内模式</li>
<li>物理结构对用户是隐蔽的</li>
</ul>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul>
<li>从一个或几个基本表导出的表</li>
<li>数据库中只存放视图的定义而不存放视图对应的数据</li>
<li>视图时一个虚表</li>
<li>用户可以在视图上再定义视图</li>
</ul>
]]></content>
      <categories>
        <category>数据库原理</category>
        <category>关系数据库标准语言SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>letter for your 21st</title>
    <url>/2022/04/07/letter-for-your-21st/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ffab6f8902b96d4c8e0f36b08faf534424ce81d913818dc8b5bb4feba91c428e">b23d15b9c62a7a3d80dca50489572af20b1231328abcbcb4dd850d949de3dd26a53282614c3049186e53b3d0709ee1055d73b537da208963c51fdd739ed734ba5e4dddcaa98a50f2b6db238551209c246cc328c418ab180ec3443e45f1fec0a76d45f75951bc3e95cb8fe3b26529ef1ac685a0c8911887101fe97ef569b85a4f89ef8fda30a93063b14082f22b045810734c42575580bd5a956b582c9732e738a91023469054058f7972d9e986eec7f7a0f1edccc948843869474db187b29ceb67dff2d4c3cfc5a684d8638a5c6a1eba1205e2ee2921a932d1df6d73fc44d9cfb7bb9de380f97f0ba861911d2cc88c98b5472f66b488f84ebaa170f16ee478d452ac63d99372283b48675bced91e5c4ce54ffdfaa878ab66f557fd2e289b3e5e155571c3a2e37ee82734b5ae25eab188ade56ce7f28b9314b2327304d42a7f19b7a2839ecadc173dd4991ce072ce9f76288e6db4a0654889c94a2ca933230f76e322669cd78f0db3f7ad8ed6bde0653995f2bad253149a6f074294d3acdf86223ac1249d47806198d1ffbba45ba7248748f57d52854c1acfff8956fed5475c784d5b5f99bc16bd78432f54b6a987026c68c9d9303d28281e354d6334978cd7dffa79c656715afc223405fe026aceb07bdd4fc9228e67904a9647a3bf06d8c97f22f614558b51231206d643f5ffc123ae16a774c034a4699da4b413aa4ac6acedda5bdd1d5f374d5a6535342b574f6a5822119a548874d08de116568f9112263fc41a2261a86311b60b2b0d314caff7df34b5f6ef60975fe9a0ec195e54308c4bbe63610032f46b8c2fcbe153c3400f97defba0240d6d3e9eeed17476b2870f0d7106991905bf005f7c20d9c5d790fb6776c14ab3141a00bc4b9d9fd021e491a26888ef254f197cd7fcb337a8175b6146b56755f434114022927bd8aab4bb253056f5a4f5f9552fefcc7c5077b14c375245dc44c42a3e6f0ade0b55fa0ab582968f0f32b64f62ce3cd59e3751584953efb22a538c5f109fab1b6eca0a6b3870eaf038f2f6284462687eeb455b6fb7190b059f9ac547fa43cc68abef767ee8fccf177b8b5cd26ee6c26f9203af47c6cc421836c5aefc240ebc8b7b8bc079bd1700cf08e076af116e4066aaa3dc90733dc60e688712f2fbb90187d7492b97c545f93e6f50912ff046f26731608d22f1f466a561891bd2f34d6d25a0446ac8be8d3e0a3ffdb8f9bc60ca6edc856a618d53ab756094097e078c345d67c5fb242b17557f34d9a308d2f651b04be55c8cd50b85b32967d661238e5c10677610564d76423c403a0601f702b063b630ed339b4eb4ff49d19a2844a866d3327fd5944b6b9fad3dd7f9495c0fd3502f9c1bd4bcbce9de2732164a3f5737350924b92e073318e6ada82d5f11fe4ee283d61326374757fd32ed0d6a1920d7b0504d581c188c52a6267bb6a61cb3085e4b40ba6df6e3f6a4104abc7b69bca4aff1fbd2825a31ff25068838fc24737bc45ead3087e420948011c19f3a21f834c9940818bc02d28dc4ba5a230b00e9261142e6b73cb271b85a58ee52486732de25af5b821af9b2f96b57c4aabda22ac00069b4fd8a9ab4108b278c588b086499eaf52d3c64a0d1f07d668681cb5d4b4455668849797a6965b263727f3bc5330de6d1f02c67dc75933a611ed5af12069d82f88f20c4131c312302abebf33e6f8c1abfd4759b6a4137b8eab3652e6d4ada7b29bd45f6908fc803639407414b92212ded9fdf1221f92769906f8267958b56776d537c851832b0457f0ba3d1328fa40967be663ac98b9ee4bbe7d27e6b4b7377da2540af4e987e292d9b747483180e1c5a63cafe63a6128d3fb1d000ea33afaefead6765f967163e390bf391b4ac620fc43d7d0529e89e0a7b2a598343b232b649d31278c135e529366aca6535e7512f634c7b8744aa13cd4330ef44da4a339a37401e667a0095103fe4bf61648b74a6106be9b38539c7d59f0f322e9557c7257ddcf7626f6381acacad832d92a9f7f960c4ac02dab220d4b9cf40ce9413e8795709f59ebc1387138f65982fb903aa323581fac166969787048e3442c07058cd1eaa62224a82152b9092976bc172f202f7eef83905de2557885e1ff9d7b143effb9f30fd8209b0c50546235470c22dc2baf07db1095f6a51d1b84b3bd737dc66ff6e2f5d5a3f13d01565a2aea9103d89a9713e54effff199972d0cc092ed2359c6f83afd7dde425b331cd2dbb6e172ccde0a66eda83f06283f6fa8f7e49120b2bef9fa2b72069b87ba2b8191a8b251b032c58750e26fd0e99696b71a5bd9efe2f4f70b33d3c8f14b92336ac6dc9d8ed554a8d1e666c98d5d22bbf6f062c0f346ea616eff29b5f6d4c61cdc02418eddef87d6c6a1cc9eb467c726d7660ae2dbfc83c7b5803967b4c9c2b1be1c7a185d9e6ab9a3fd1978d34803c2fa08d6499fd004ceeb9988fdbf00c53f7cc9233aa24a83f33bb50ec764ca2e28a7f4e17aeb8e54cfe456938238e4990f0f0b574cf85299397c32757740bfd6df77fd1a21e9d780bdb3f37515d6f4370ead57272340269a325fa1e69b11a5419133fe76f665e4b876867e17f98411371b5eaa176cfaf769b50853ce5b1a7c04d632917d0b7e685d2a85d49bf59b6f54ce4190452b8b9e8ef629689711789d3ab79ca6e7fa33a14b332f78febfd3a8dbb857aec5c53efaf3c505348efb459ce97e02c60c77822f0814468ce1560bf2ec92177443cafab48beefc7b22a571156fe54a1a6857c707fcfd7dfa6270d45df200fa42afb532ced8d0a198e00f927be22733379c4530d8dcef0e60081b3d4a86543a83ec18500fcbbe56db2b18628cb30c5ff7b011382ec5dfbb2b058cb8727a6d3e54427d92b3402b4793718d156497d5592ff22ce91f1465c7641826891eafa618e96bd0a94ca951363c34faa41abf13b6e9673611ee446dc1fc5457719ca92d04b78396e5abebcf544e97a9adea5f1a1a7a13a5518714a6b48e76b79183d80ec377a51f396e77c303f14285ffb6e5ad72e9b865bb7e784ed5f31626eb9762f1f240970eb54eedecd73523875e05bfaa3c28633952765676936ce8d837bf49a8c416af8088332d143f8051121238d61eff5feff4de0ae78bcf52823dd2aeaa1e85bf305e0d5635036ef55992feb13e532ece2f986ea73d59357423206f3c2f67646a795d5f7099edcbee304ca256aea758b77b5429026a1e12f4a73def0a4e04c26f462f760e0148d4aee721d5a6c698144605c2ed555f4a1d9557284948057860c5d23527fe5c38a909192fd3aba7acb5cf5c2f2ca2053e230b3867d2b81820926af5a9ff4fef3fd6e921c37d21ba75759e4d2aea392c8a26f885b22128d0994fc61f3b6d7eb94f428a3474cb103736a8782e21742eeaa2397c24618221d2de53d547b2b1d17f0abb69bdb0ee039963b7d550938c9b93273c2429bba5aa5a5ed79bc66777f43df392bbee6ba2de2e899deed11f1d28c5cb1b44c4a2d221b1b1ac9d9bae823ce6deaca8fb086520443c88fc6ffcdeeae319820d2ac6e917558a58ffbdb265e605af5514bca7b462811f5a802acd67f477f6866450ee36d4aaa1061f398a38e0899148e7fa243fdb30687481cb5e691ac9147d9d6e94ebcfd5529166f5c3b95267d0e310232cf265c1df80917ac30004f27a2965c08ef950c27f487cbaae6689f0af4dc3c548a2f1260f42eab24148db35e21bc8fb92668e00d02e2ef3258fd2c29ee9bf0f0ed33ff1d1d46a7a7a30b4750d6f2b8c719d2fc8625d0315e9b060e05db17e837808dbd980f0a8967cdf1c1e40c3f54e9d442b53c262fe539c5011bc7370b8f6a936292976fdeef1851ec871243b79188d8d5806a747c1023fc9eb73d743279fe68c1fcaef5068982e389d41210b3cefd4fc7dd0c1de4d449e973eeefe122185f059375734802a01eb56ac6dec7cb1e9e6471833f59c9d286bb63e017e474ae748937a469933568946eafde2f62d696b2df683e0d871376bd1b746141a628373d76c75f18a3a53a54db8e3dcb75fe2706a2a31e65212caa6d5263e9d80c4d1520aa978e162bcc41cb65ed8861c464f6db7e7659af535d55f7e370cdd5a522b5ba145f25df4138310fe5ad7bdf73b5ab98d63efc2f42680493caf00dcf1d52c0f5b5a520a65a14e33e93e74d11eb91e6d29087e8c598a8f986b4a49d1c51c33bf1cb08d859c10e05644d52329ffdb697577e77a91f0471cb461d21b287ea0b1418a6e680d4b3958ce5403e22fbfef1cd421a67eae043736d9050bb8bc387ac1fbc800b141bac7cf90be669c839e89be4346b274f2a9c04b3193d6a8fdec3de0b9627e6094f8ded58bac316f70fc89627dd08d649899a6733089888c264079849b5c76d2f680102acbc7f6dfbd73d8ad4d3ec0d460466859a56d5069b1a9fc3184f9554ad24d859f9d3405d57fb137e64f3c535d7a4080592f744427ada729d3c040378be14183f57ba54f2616168d6779bcf06d9d3ac49c611a39cfdde7aca8f413881330fea029dcd0a573ee4cd7f70a622623ffda5e692b0b1084169b7e98a9f7255578d1aefc9a63d9787c8790486c963f5bf1d9405bf6be8e0d80ec8f53300696a9aa40a3646c78b022b407fe6e0d3020143d63d0aeff3c725feafae3602ff828616dba0cd7313fdaa9217e00322267a424b12c5bbd7d037fad5222e4fce036ae1d9e2e2e43e8ad6225bfaf7b343e1151986515970033973bd89999918640d16f73c60f4b5303ee7275de4d0603eacdd61107c896af1735a706911f561877b81828818f65186346bb8085a51e3a46ecb3a1e56bbdb2e0af7069bc3bc0508a1731dc3f9ce7951f225b6d602c486f07fb2ea9fb4ad47f5ddfc3eca97345215e5dccb0ca3cd2d8ef0f7f9805da66f5ba2023c5e7234fbd026ff359333227fc292b317f5035e957951bee8c31bcaa3550aa12c959510633db26691ee6515e84051fffc6e7c26c29bc6b6d46e3bf1c357735a544e368160788423bf28939a907b129574b46acbfc3a3ae817d4adafb0a15ef2bfa1be4a707944a516e3dea457d493e46cd602f2e718792ed0ff04e0b3df26cd9a7d1ad5523afa4a72d73d38bb61ca511d0bdc6a264a0b5256cd8758900945136e0c888a5d344f2818e50c81df6508cc366c920e6f0e7a697ee222bf49265574f108b97d236a2a96d1124773014d6b3770201db72fc55a87e0ccde867f919a64b6127276c604630eafb57522bc915a0ebbfaf67ca7565878563529cfba9d22d7e9507cb86e7fca09e2cdae414e862010dcfa1943c7a5fd4270aee6ef72ccf28fbbd2b44cac02b6539bf65b68b91a8f837f5bb2983bd6004b645b95e1586650ba42da1267c6ebefe83b10903eafdac321fe6ff8c72b1290c192f3ff6a0325b40d57866414bd86adb8ced062ca048c7990319c1b4e3b0432ddf69c4faffe3de2f2ac5a5a67a99c0fd3b020bc5f8342d467f2f90ee6052345e3f59afe63a3155356007c1e8f2a689d5aebb8b6dd87fdfc6a5c783e4d09f34e9d42ab521160ca0823091d7b135022e8b17f028ebaf98ac42fdce6c169a13d3ce99f1fff85a17a43592ee33c1b69dd5fd72b831272157adf25543a08be2d4fbf6905e8fa3d4443ae237ffc06c0ab64e175d66448fec34f9cecafdc4c885de42fabb695331f78a0e9c643f5b0894b75dcd2f207e448af21a30cad1234831340c16bc28f5e5bb4cf22f0a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>写给STico</category>
        <category>2022</category>
      </categories>
      <tags>
        <tag>personal</tag>
      </tags>
  </entry>
  <entry>
    <title>简明手册</title>
    <url>/2022/04/01/markdown/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>介绍hexo常用的命令以及markdown常用语法</p>
<span id="more"></span>
<h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span>		<span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span><span class="comment">#新建页面</span></span><br><span class="line">hexo generate 			<span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server 			<span class="comment">#开启预览访问端口</span></span><br><span class="line">hexo deploy 			<span class="comment">#部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  				<span class="comment">#查看帮助</span></span><br><span class="line">hexo version  			<span class="comment">#查看Hexo的版本</span></span><br><span class="line">hexo clean 				<span class="comment">#清理public的内容</span></span><br><span class="line">组合命令：</span><br><span class="line">hexo s -g			 	<span class="comment">#生成并本地预览</span></span><br><span class="line">hexo d -g		 		<span class="comment">#生成并上传</span></span><br></pre></td></tr></table></figure>

<h2 id="备份与自动部署"><a href="#备份与自动部署" class="headerlink" title="备份与自动部署"></a>备份与自动部署</h2><p><code>hexo d</code>和<code>hexo d</code> 只是将生成的静态文件部署到了云端。</p>
<p>为了备份，将网站的源代码文件也推送到GitHub仓库备份。</p>
<p><code>你的名字.github.io</code> 部署后，GitHub Pages 将默认使用你的 main 分支作为静态文件部署。所以我们最好新建一个 hexo 分支（命名无所谓）用来存储 Hexo 地源代码，master 分支则用来存储部署后的静态文件。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure>
<p>这时便成功建立了一个 hexo 分支。（此后的工作都将在 hexo 分支下进行）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/你的用户名/你的名字.github.io</span><br></pre></td></tr></table></figure>
<p>接下来准备提交，这几句命令将是你以后每次备份所需要输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加到缓存区</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;这次做了什么更改，简单描述下即可&quot;</span></span><br><span class="line"><span class="comment"># 推送至远程仓库</span></span><br><span class="line">git push</span><br><span class="line"><span class="comment"># 第一次提交，你可能需设置一下默认提交分支</span></span><br><span class="line"><span class="comment"># git push --set-upstream origin hexo</span></span><br></pre></td></tr></table></figure>

<p>每次推送都要输入这三条命令，你可能觉得有些麻烦。<br>那么你可以编写 bash 脚本。</p>
<p>譬如，在根目录下新建 <code>update.sh</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果没有消息后缀，默认提交信息为 `:pencil: update content`</span></span><br><span class="line">info=$<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> [<span class="string">&quot;$info&quot;</span> = <span class="string">&quot;&quot;</span>];</span><br><span class="line">then info=<span class="string">&quot;:pencil: update content&quot;</span></span><br><span class="line">fi</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;$info&quot;</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>

<p>此后更新的话，只需要在终端执行 <code>sh update.sh</code> 即可。</p>
<h2 id="Hexo-Markdown简明语法"><a href="#Hexo-Markdown简明语法" class="headerlink" title="Hexo Markdown简明语法"></a>Hexo Markdown简明语法</h2><h3 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h3><p>使用<code>*</code>和<code>**</code>表示斜体和粗体，格式如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="strong">*斜体*</span>，<span class="strong">**粗体**</span></span><br></pre></td></tr></table></figure>
<p>效果如下：<em>斜体</em>，<strong>粗体</strong></p>
<h3 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h3><p>使用 <code>===</code>表示一级标题，使用<code>---</code>表示二级标题，格式如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">这是一个一级标题</span></span><br><span class="line"><span class="section">===</span></span><br><span class="line"><span class="section">这是一个二级标题</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>或者：使用<code>#</code>号（建议<code>#</code>后面跟一个空格）</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># H1</span><br><span class="line">## H2</span><br><span class="line">### H3</span><br><span class="line">#### H4</span><br><span class="line">##### H5</span><br><span class="line">###### H6</span><br></pre></td></tr></table></figure>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>在单独的一行使用<code>***</code>或者<code>___</code>表示分割线</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">part1</span><br><span class="line"><span class="emphasis">___</span> (三个下划线)</span><br><span class="line">part2</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>part1</p>
<hr>
<p>part2</p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>使用<code>~~</code>表示删除线<br>（<code>~~</code>要紧跟文字不能空格）</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">~~我被划了吗？~~</span><br></pre></td></tr></table></figure>
<p><del>我被划了吗？</del></p>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><p>插入文字超链接的格式如下 ：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[链接文字](链接地址 <span class="string">&quot;链接标题&quot;</span>)</span><br><span class="line">eg:</span><br><span class="line">hexo搭建时自动生成的[第一篇文章](https:<span class="regexp">//</span>jennycruise.github.io<span class="regexp">/2022/</span><span class="number">04</span><span class="regexp">/01/</span>hello-world/ <span class="string">&quot;helloworld&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>hexo搭建时自动生成的<a href="https://jennycruise.github.io/2022/04/01/hello-world/" title="helloworld">第一篇文章</a></p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>插入图片超链接的格式如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">![图片说明](图片链接 <span class="string">&quot;图片标题&quot;</span>)</span><br><span class="line">eg:</span><br><span class="line">![亮色模式背景](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>JennyCruise<span class="regexp">/mycdn/</span>bg_light.jpg <span class="string">&quot;bg_light&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>eg:<br><img src="https://cdn.jsdelivr.net/gh/JennyCruise/mycdn/bg_light.jpg" alt="亮色模式背景" title="bg_light"></p>
<h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><p>插入音频，使用插件hexo-tag-aplayer，语法如下：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">aplayer</span> title author url [picture_url, narrow, autoplay, width:xx%, lrc:xxx] %&#125;</span></span><br></pre></td></tr></table></figure>
<p>详情参见：hexo-tag-aplayer <a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">中文使用文档</a></p>
<h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><p>引用视频则直接插入iframe代码：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;script src<span class="operator">=</span><span class="string">&quot;/js/youtube-autoresizer.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;iframe width<span class="operator">=</span><span class="string">&quot;640&quot;</span> height<span class="operator">=</span><span class="string">&quot;360&quot;</span> src<span class="operator">=</span><span class="string">&quot;https://www.youtube.com/embed/HfElOZSEqn4&quot;</span> frameborder<span class="operator">=</span><span class="string">&quot;0&quot;</span> allowfullscreen&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>用<code>\</code>表示注释，<code>\</code>后面的文字解析为纯文本格式。<br>渲染效果：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">\## 看我没有变成二级标题吧</span><br></pre></td></tr></table></figure>
<p>## 看我没有变成二级标题吧</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="普通引用"><a href="#普通引用" class="headerlink" title="普通引用"></a>普通引用</h4><p>使用<code>&gt;</code>表示文字引用：<br>(必须要在每行的开头)</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">野火烧不尽，</span></span><br><span class="line">春风吹又生</span><br><span class="line"></span><br><span class="line">遇到换行结束</span><br></pre></td></tr></table></figure>
<p>eg：</p>
<blockquote>
<p>野火烧不尽，<br>春风吹又生</p>
</blockquote>
<p>遇到换行结束 </p>
<h4 id="嵌套引用"><a href="#嵌套引用" class="headerlink" title="嵌套引用"></a>嵌套引用</h4><figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">最外层引用</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">&gt; 第二层引用</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">&gt; &gt; 可以嵌套很多层</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>最外层引用</p>
<blockquote>
<p>第二层引用</p>
<blockquote>
<p>可以嵌套很多层</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="引用嵌套列表"><a href="#引用嵌套列表" class="headerlink" title="引用嵌套列表"></a>引用嵌套列表</h4><figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">- 这是引用里嵌套的一个列表</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">- 还可以有子列表</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">	- 子列表</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">	- 子列表</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这是引用里嵌套的一个列表</li>
<li>还可以有子列表<ul>
<li>子列表</li>
<li>子列表</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="引用嵌套代码"><a href="#引用嵌套代码" class="headerlink" title="引用嵌套代码"></a>引用嵌套代码</h4><figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">    同样的，在前面加四个空格形成代码块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="string">``</span><span class="string">`</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="string">或者使用三个反引号形成代码块</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="string">`</span><span class="string">``</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<pre><code>同样的，在前面加四个空格形成代码块
</code></pre>
</blockquote>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">或者使用三个反引号形成代码块</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="列表与表格"><a href="#列表与表格" class="headerlink" title="列表与表格"></a>列表与表格</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>使用<code>*</code>, <code>+</code>, <code>-</code> 来显示无序列表<br>(后面加空格)</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span> 无序列表项 一</span><br><span class="line"><span class="bullet">	-</span> 子无序列表 一</span><br><span class="line"><span class="bullet">	-</span> 子无序列表 二</span><br><span class="line"><span class="bullet">		*</span> 子无序列表 三</span><br><span class="line"><span class="bullet">+</span> 无序列表项 二</span><br><span class="line"><span class="bullet">+</span> 无序列表项 三</span><br></pre></td></tr></table></figure>
<p>效果展示：</p>
<ul>
<li>无序列表项 一<ul>
<li>子无序列表 一</li>
<li>子无序列表 二<ul>
<li>子无序列表 三</li>
</ul>
</li>
</ul>
</li>
<li>无序列表项 二</li>
<li>无序列表项 三<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4>使用数字和点表示有序列表：<br>(同样的，要加空格)<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 有序列表项 一</span><br><span class="line"><span class="bullet">	1.</span> 子有序列表项 一</span><br><span class="line"><span class="bullet">	2.</span> 子有序列表项 二</span><br><span class="line"><span class="bullet">	4.</span> 故意标错，会自动排序</span><br><span class="line"><span class="bullet">2.</span> 有序列表项 二</span><br><span class="line"><span class="bullet">3.</span> 有序列表项 三</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>有序列表项 一<ol>
<li>子有序列表项 一</li>
<li>子有序列表项 二</li>
<li>故意标错，会自动排序</li>
</ol>
</li>
<li>有序列表项 二</li>
<li>有序列表项 三<h3 id="绘制表格"><a href="#绘制表格" class="headerlink" title="绘制表格"></a>绘制表格</h3>绘制表格格式如下：<br><code>|</code> 控制分列，<br><code>-</code> 控制分行，<br><code>:</code> 控制对齐方式。</li>
</ol>
<p>示例：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string"> 这是标题 </span>|<span class="string"> 自动加粗 </span>|<span class="string"> 标题下指定对齐方式 </span>|<span class="string"> 不指定对齐方式 </span>|</span><br><span class="line">|<span class="string"> :------- </span>|<span class="string"> --------: </span>|<span class="string"> :---: </span>|<span class="string">---</span>|</span><br><span class="line">|<span class="string"> ↑左对齐 </span>|<span class="string"> 右对齐↑  </span>|<span class="string"> ↑居中↑     </span>|<span class="string">默认左对齐</span>|</span><br><span class="line">|<span class="string"> 123456789    </span>|<span class="string"> ←空格不占位置   </span>|<span class="string"> 987654321 </span>|<span class="string"> 1 </span>|</span><br><span class="line">|<span class="string"> 123456789</span>|<span class="string"> ←没有空格     </span>|<span class="string"> 987654321 </span>|<span class="string"> 0 </span>|</span><br></pre></td></tr></table></figure>
<p>效果展示：</p>
<table>
<thead>
<tr>
<th align="left">这是标题</th>
<th align="right">自动加粗</th>
<th align="center">标题下指定对齐方式</th>
<th>不指定对齐方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">↑左对齐</td>
<td align="right">右对齐↑</td>
<td align="center">↑居中↑</td>
<td>默认左对齐</td>
</tr>
<tr>
<td align="left">123456789</td>
<td align="right">←空格不占位置</td>
<td align="center">987654321</td>
<td>1</td>
</tr>
<tr>
<td align="left">123456789</td>
<td align="right">←没有空格</td>
<td align="center">987654321</td>
<td>0</td>
</tr>
</tbody></table>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><p>使用<code>`</code>符号</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">可以用 `一个`，</span><br><span class="line">可以用 ``两个``，</span><br><span class="line">也可以用 ```三个```，</span><br><span class="line">总之就是要 ````成对````。</span><br></pre></td></tr></table></figure>
<p>可以用 <code>一个</code>，<br>可以用 <code>两个</code>，<br>也可以用 <code>三个</code>，<br>总之就是要 <code>成对</code>。</p>
<h4 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h4><p>使用：<code>`</code>符号<br>至少要三个连续的 <code>`</code>，数目要配对</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdion.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;hello world!&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdion.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;hello world!&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加强的代码块"><a href="#加强的代码块" class="headerlink" title="加强的代码块"></a>加强的代码块</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdion.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;hello world!&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdion.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;hello world!&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>end</strong></em></p>
]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>关系代数</title>
    <url>/2022/04/20/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>关系代数是一种抽象的查询语言，它用<em>对关系的运算</em>来表达<em>查询</em></li>
<li>三要素：<ul>
<li>运算对象</li>
<li>运算结果</li>
<li>运算符</li>
</ul>
</li>
<li>按运算符分类：<ul>
<li>传统的集合运算（水平）</li>
<li>专门的关系运算（行列）</li>
</ul>
</li>
</ul>
<img src="运算符.png" style="zoom:50%;" />

<span id="more"></span>

<h2 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h2><h3 id="并（∪）"><a href="#并（∪）" class="headerlink" title="并（∪）"></a>并（∪）</h3><ul>
<li><p>R 和 S</p>
<ul>
<li>具有相同的目n（即两个关系都有n个属性）</li>
<li>相应的属性取自同一个域</li>
</ul>
</li>
<li><p>R ∪ S</p>
<ul>
<li><p>仍为n目关系，由 <em>属于R或属于S</em> 的元组组成 </p>
<p>R∪S &#x3D; { t | t ∈ R ∨ t ∈ S  }</p>
</li>
</ul>
</li>
</ul>
<img src="并.png" style="zoom:50%;" />

<h3 id="差（-）"><a href="#差（-）" class="headerlink" title="差（ - ）"></a>差（ - ）</h3><ul>
<li><p>R 和 S</p>
<ul>
<li>具有相同的目 n</li>
<li>相应的属性取自同一个域</li>
</ul>
</li>
<li><p>R - S</p>
<ul>
<li><p>仍为n目关系，由 <em>属于R而不属于S</em> 的元组组成 </p>
<p>R - S &#x3D; { t | t ∈ R  ∧ t ∉ S  }</p>
</li>
</ul>
</li>
</ul>
<img src="差.png" style="zoom:50%;" />

<h3 id="交（-∩-）"><a href="#交（-∩-）" class="headerlink" title="交（ ∩ ）"></a>交（ ∩ ）</h3><ul>
<li><p>R 和 S</p>
<ul>
<li>具有相同的目 n</li>
<li>相应的属性取自同一个域</li>
</ul>
</li>
<li><p>R - S</p>
<ul>
<li><p>仍为n目关系，由 <em>既属于R也属于S</em> 的元组组成 </p>
<p>R - S &#x3D; { t | t ∈ R  ∧ t ∉ S  }</p>
</li>
</ul>
</li>
</ul>
<img src="交.png" style="zoom:50%;" />

<h3 id="笛卡尔积（-×-）"><a href="#笛卡尔积（-×-）" class="headerlink" title="笛卡尔积（ × ）"></a>笛卡尔积（ × ）</h3><p>（广义笛卡尔积）</p>
<ul>
<li>R 和 S<ul>
<li>R: n目关系，k1个元组</li>
<li>S: m目关系，k2个元组</li>
</ul>
</li>
<li>R × S<ul>
<li>列：(n+m) 列元组的集合<ul>
<li>元组的前n列是关系R的一个元组</li>
<li>后m列是关系S的一个元组</li>
</ul>
</li>
<li>行：k1 × k2个元组</li>
</ul>
</li>
</ul>
<img src="笛卡尔积.png" style="zoom:50%;" />

<h2 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h2><h3 id="先行"><a href="#先行" class="headerlink" title="先行"></a>先行</h3><ol>
<li><img src="先行1.png" style="zoom:67%;" />
</li>
<li><img src="先行2.png" style="zoom:63%;" />
</li>
<li><img src="先行3.png" style="zoom:68%;" />
</li>
<li><img src="先行4.png" style="zoom:60%;" /></li>
</ol>
<img src="像集.png" style="zoom:50%;" />

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>学生-课程数据库：</strong></p>
<p>​    <em>学生关系 Student、课程关系 Course 和 选修关系 SC</em></p>
<h4 id="Student"><a href="#Student" class="headerlink" title="Student"></a><em><strong>Student</strong></em></h4><table>
<thead>
<tr>
<th>学号<br />Sno</th>
<th>姓名<br />Sname</th>
<th>性别<br />Ssex</th>
<th>年龄<br />Sage</th>
<th>所在系<br />Sdept</th>
</tr>
</thead>
<tbody><tr>
<td>201215121</td>
<td>李勇</td>
<td>男</td>
<td>20</td>
<td>CS</td>
</tr>
<tr>
<td>201215122</td>
<td>刘晨</td>
<td>女</td>
<td>19</td>
<td>CS</td>
</tr>
<tr>
<td>201215123</td>
<td>王敏</td>
<td>女</td>
<td>18</td>
<td>MA</td>
</tr>
<tr>
<td>201215125</td>
<td>张立</td>
<td>男</td>
<td>19</td>
<td>IS</td>
</tr>
</tbody></table>
<hr>
<h4 id="Course"><a href="#Course" class="headerlink" title="Course"></a><em><strong>Course</strong></em></h4><table>
<thead>
<tr>
<th>课程号<br />Cno</th>
<th>课程名<br />Cname</th>
<th>先行课<br />Cpno</th>
<th>学分<br />Ccredit</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>数据库</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>数学</td>
<td></td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>信息系统</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>操作系统</td>
<td>6</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>数据结构</td>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>数据处理</td>
<td></td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>Pascal语言</td>
<td>6</td>
<td>4</td>
</tr>
</tbody></table>
<hr>
<h4 id="SC"><a href="#SC" class="headerlink" title="SC"></a><em><strong>SC</strong></em></h4><table>
<thead>
<tr>
<th>学号<br />Sno</th>
<th>课程号<br />Cno</th>
<th>成绩<br />Grade92</th>
</tr>
</thead>
<tbody><tr>
<td>201215121</td>
<td>1</td>
<td>92</td>
</tr>
<tr>
<td>201215121</td>
<td>2</td>
<td>85</td>
</tr>
<tr>
<td>201215121</td>
<td>3</td>
<td>88</td>
</tr>
<tr>
<td>201215122</td>
<td>2</td>
<td>90</td>
</tr>
<tr>
<td>201215122</td>
<td>3</td>
<td>80</td>
</tr>
</tbody></table>
<hr>
<h3 id="选择-σ"><a href="#选择-σ" class="headerlink" title="选择 ( σ )"></a>选择 ( σ )</h3><blockquote>
<p>选择运算是从关系R中选取使逻辑表达式F为真的元组，是从<strong>行的角度</strong>进行的运算</p>
</blockquote>
<p>eg 2.4</p>
<img src="选择1.png" style="zoom:50%;" />

<p>eg 2.5</p>
<img src="选择2.png" style="zoom:50%;" />

<h3 id="投影-Π"><a href="#投影-Π" class="headerlink" title="投影 ( Π )"></a>投影 ( Π )</h3><blockquote>
<p>从R中选择出若干属性列组成新的关系，主要是从<strong>列的角度</strong>进行运算</p>
<p>投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）</p>
</blockquote>
<p>$$<br>Π_A(R)&#x3D;{ t [A] | t ∈ R }<br>$$</p>
<p>A: R 中的属性列</p>
<p>eg 2.6</p>
<img src="投影1.png" style="zoom:50%;" />

<p>eg 2.7</p>
<img src="投影2.png" style="zoom:50%;" />



<h3 id="连接-⋈"><a href="#连接-⋈" class="headerlink" title="连接 ( ⋈ )"></a>连接 ( ⋈ )</h3><blockquote>
<p>分为<strong>等值连接</strong>和<strong>自然连接</strong></p>
</blockquote>
<p>eg 2.8 关系R和关系S 如下所示：</p>
<img src="image-20220427215751097.png" alt="image-20220427215751097" style="zoom:50%;" />

<p>一般连接：</p>
<img src="image-20220427215833155.png" alt="image-20220427215833155" style="zoom:50%;" />

<p>等值连接</p>
<img src="image-20220427215856240.png" alt="image-20220427215856240" style="zoom:50%;" />

<p>自然连接</p>
<img src="image-20220427215920881.png" alt="image-20220427215920881" style="zoom:50%;" />



<h3 id="除运算-÷"><a href="#除运算-÷" class="headerlink" title="除运算 ( ÷ )"></a>除运算 ( ÷ )</h3><p>同时从行和列角度进行运算</p>
<p>给定关系<em><strong>R (X，Y)</strong></em> 和***S (Y，Z)***，其中X，Y，Z为属性组。<br><code>（ R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。）</code></p>
<p> R与S的除运算得到一个新的关系**P(X)**， P是R中满足下列条件的元组在 X属性列上的投影： </p>
<p>元组在<strong>X</strong>上分量值 <strong>x</strong> 的象集 Yx 包含 S 在 Y 上投影的集合，记作：</p>
<p>$$<br>R÷S &#x3D; { tr [X] | tr ∈ R ∧ Π_Y(S)⊆Y_x }<br>$$<br>Yx：x在R中的象集，x &#x3D; tr[X]</p>
<p>eg 2.9</p>
<img src="image-20220427220546061.png" alt="image-20220427220546061" style="zoom:50%;" />

<h3 id="综合举例"><a href="#综合举例" class="headerlink" title="综合举例"></a>综合举例</h3><p>书本P56</p>
]]></content>
      <categories>
        <category>数据库原理</category>
        <category>关系数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>关系操作</title>
    <url>/2022/04/20/%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Nothing to say</p>
<span id="more"></span>

<h2 id="基本的关系操作"><a href="#基本的关系操作" class="headerlink" title="基本的关系操作"></a>基本的关系操作</h2><p><strong>常用的关系操作</strong></p>
<ul>
<li>查询操作：<code>选择</code>， <code>投影</code>, <code>连接</code> , <code>除</code>, <code>并</code> ,  <code>差</code>,  <code>交</code>, <code>笛卡尔积</code> <ul>
<li><code>选择</code>、<code>投影</code>、<code>并</code>、<code>差</code>、<code>笛卡尔积</code>是5种基本操作</li>
</ul>
</li>
<li>关系操作的特点<ul>
<li>集合操作方式：操作的对象和结果都是集合，一次一集 合的方式</li>
</ul>
</li>
</ul>
<h2 id="关系数据库语言的分类"><a href="#关系数据库语言的分类" class="headerlink" title="关系数据库语言的分类"></a>关系数据库语言的分类</h2><ul>
<li>关系代数语言<ul>
<li>用对关系的运算来表达查询要求</li>
<li>eg：ISBL</li>
</ul>
</li>
<li>关系演算语言<ul>
<li>元组关系演算语言<ul>
<li>谓词变元的基本对象是元组变量</li>
<li>eg：ALPHA, QUEL</li>
</ul>
</li>
<li>域关系演算语言<ul>
<li>谓词变元的基本对象是域变量</li>
<li>eg：QBE</li>
</ul>
</li>
</ul>
</li>
<li>具有关系代数和关系演算双重特点的语言<ul>
<li>eg：SQL（Structured Query Language）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库原理</category>
        <category>关系数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>关系数据结构及形式化定义</title>
    <url>/2022/04/20/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>讲解关系数据结构，包括关系的形式化定义及有关概念</p>
<span id="more"></span>

<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="域（domain）"><a href="#域（domain）" class="headerlink" title="域（domain）"></a>域（domain）</h3><p><strong>域</strong> 是一组具有相同数据类型的值的集合</p>
<h3 id="笛卡尔积（Cartesian-Product）"><a href="#笛卡尔积（Cartesian-Product）" class="headerlink" title="笛卡尔积（Cartesian Product）"></a>笛卡尔积（Cartesian Product）</h3><p>给定一组域D1，D2，…，Dn，允许其中某些域是相同的。 </p>
<p>D1，D2，…，Dn的笛卡尔积为：</p>
<p> <code>D1×D2×…×Dn＝｛（d1，d2，…，dn）｜di ∈ Di，i ＝ 1，2，…，n  ｝</code></p>
<p><strong>元组</strong></p>
<blockquote>
<p>笛卡尔积中每一个元素（d1，d2，…，dn）叫作一个n元组 （n-tuple）或简称元组</p>
</blockquote>
<p><strong>分量</strong></p>
<blockquote>
<p>笛卡尔积元素（d1，d2，…，dn）中的每一个值di 叫作一个 分量</p>
</blockquote>
<p><strong>基数</strong></p>
<blockquote>
<p>若Di（i＝1，2，…，n）为有限集，其基数为mi（i＝1， 2，…，n），则D1×D2×…×Dn的基数M为：</p>
<p>M &#x3D; Π(i: 1-&gt;n) mi</p>
</blockquote>
<h3 id="关系（relation）"><a href="#关系（relation）" class="headerlink" title="关系（relation）"></a>关系（relation）</h3><p><strong>关系</strong></p>
<blockquote>
<p>D1×D2×…×Dn的子集叫作在域D1，D2，…，Dn上的 关系，表示为:</p>
<p><code>R（D1，D2，…，Dn）</code></p>
<p>R：关系名， n：关系的目或度（degree）</p>
</blockquote>
<p><strong>元组</strong></p>
<blockquote>
<p>关系中的每个元素是关系中的元组，通常用 <em><strong>t</strong></em> 表示</p>
</blockquote>
<p><strong>单元关系与二元关系</strong></p>
<blockquote>
<p>当n&#x3D;1时，称该关系为单元关系（Unary relation） 或一元关系<br>当n&#x3D;2时，称该关系为二元关系（Binary relation）</p>
</blockquote>
<p><strong>关系的表示</strong></p>
<blockquote>
<p>关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域</p>
</blockquote>
<p><strong>属性</strong></p>
<blockquote>
<p>为了加以区分，必须对每列起一个名字，称为属性</p>
</blockquote>
<p><strong>码</strong></p>
<ul>
<li>候选码（candidate key）</li>
</ul>
<blockquote>
<p>若关系中的某一属性组的值能<em>唯一</em>地标识一个元组，而其真子集不能，则称该属性组为候选码 简单的情况：候选码只包含一个属性</p>
</blockquote>
<ul>
<li><p>全码（All-key）</p>
<blockquote>
<p>最极端的情况：关系模式的<em>所有</em>属性组是这个关系模式的候选码，称为全码（All-key）</p>
</blockquote>
</li>
<li><p>主码</p>
<blockquote>
<p>若一个关系有多个候选码，则选定其中一个为主码（Primary key）</p>
</blockquote>
</li>
<li><p>主属性</p>
<blockquote>
<p>候选码的诸属性称为主属性（Prime attribute） 不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute</p>
</blockquote>
</li>
</ul>
<h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><p>关系模式是 <em>型</em> ，关系是 <em>值</em> 。<br>关系模式是对关系的描述</p>
<p><strong>关系模式可以形式化地表示为：</strong></p>
<blockquote>
<p>R（U，D，DOM，F） </p>
<p>R          关系名<br>U          组成该关系的属性名集合<br>D          U中属性所来自的域<br>DOM    属性向域的映象集合<br>F          属性间数据的依赖关系的集合</p>
</blockquote>
<p><strong>关系模式通常可以简记为：</strong></p>
<blockquote>
<p>R (U) 或 R (A1，A2，…，An)</p>
<ul>
<li><p>R: 关系名</p>
</li>
<li><p>A1，A2，…，An : 属性名</p>
<p>注：域名及属性向域的映象常常直接说明为 属性的类型、长度</p>
</li>
</ul>
</blockquote>
<h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><ul>
<li>在一个给定的应用领域中，所有关系的集合构成一个 <em><strong>关系数据库</strong></em></li>
<li>关系数据库的型: 关系数据库模式，是对关系数据库的描述</li>
<li>关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库</li>
</ul>
<h2 id="关系模型的存储结构"><a href="#关系模型的存储结构" class="headerlink" title="关系模型的存储结构"></a>关系模型的存储结构</h2><ul>
<li>有的关系数据库管理系统中一个表对应一个操作系统 文件，将物理数据组织交给操作系统完成</li>
<li>有的关系数据库管理系统从操作系统那里申请若干个 大的文件，自己划分文件空间，组织表、索引等存储 结构，并进行存储管理</li>
</ul>
]]></content>
      <categories>
        <category>数据库原理</category>
        <category>关系数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>关系的完整性</title>
    <url>/2022/04/20/%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>关系的三类完整性约束：</p>
<ul>
<li><p>实体完整性 &amp; 参照完整性</p>
<blockquote>
<p>关系模型必须满足的完整性约束条件，称为<code>关系的两个不变性</code>，应该由关系系统自动支持</p>
</blockquote>
</li>
<li><p>用户定义的完整性</p>
<blockquote>
<p>应用领域需要遵循的约束条件，体现了具体领域中的语义约束</p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><ul>
<li>若属性A是基本关系R的主属性，则属性A不能取空值</li>
<li>空值就是“不知道”或“不存在”或“无意义”的值</li>
</ul>
<p>eg: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">选修（学号，课程号，成绩） </span><br><span class="line">	“学号、课程号”为主码 </span><br><span class="line">	“学号”和“课程号”两个属性都不能取空值</span><br></pre></td></tr></table></figure>

<p>实体完整性规则的说明：</p>
<ol>
<li>实体完整性规则是针对基本关系而言的。<br> 一个基本表通常对应现实世界的一个实体集。</li>
<li>现实世界中的实体是可区分的，<br>即它们具有某种唯 一性标识</li>
<li>关系模型中以主码（候选码）作为唯一性标识。</li>
<li>主码中的属性是主属性（候选码的诸属性）不能取空值</li>
</ol>
<blockquote>
<p>主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，<br>这与第（2）点相矛盾，因此这个规则称为实体完整性</p>
</blockquote>
<h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><h3 id="关系间的引用"><a href="#关系间的引用" class="headerlink" title="关系间的引用"></a>关系间的引用</h3><p><strong>在关系模型中实体及实体间的联系都是用关系来 描述的，自然存在着关系与关系间的引用。</strong></p>
<blockquote>
<p>eg：</p>
<p>学生（<em>学号</em>，姓名，性别，专业号，年龄）<br>专业（<em>专业号</em>，专业名）</p>
<p>学生关系引用了专业关系的主码“专业号”<br>学生关系中的“专业号”值必须是确实存在的专业的专业号</p>
</blockquote>
<h3 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h3><ul>
<li>设F是基本关系R的一个或一组属性，但不是关系R的码。 如果F与基本关系S的主码Ks相对应，则称F是R的外码</li>
<li>基本关系R称为参照关系（Referencing Relation）</li>
<li>基本关系S称为被参照关系（Referenced Relation） 或目标关系（Target Relation）</li>
</ul>
<blockquote>
<p>eg</p>
<p> [例2.1]中学生关系的“专业号”与专业关系的主码“专业号”相对应 </p>
<ul>
<li>“专业号”属性是学生关系的外码</li>
<li>专业关系是被参照关系，学生关系为参照关系</li>
</ul>
</blockquote>
<ul>
<li><p>关系R和S不一定是不同的关系</p>
</li>
<li><p>目标关系S的主码Ks和参照关系的外码F必须定义在同一个（或一组）域上</p>
</li>
<li><p>外码并不一定要与相应的主码同名</p>
<p>当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别</p>
</li>
</ul>
<h3 id="参照完整性规则"><a href="#参照完整性规则" class="headerlink" title="参照完整性规则"></a>参照完整性规则</h3><p><strong>规则2.2 参照完整性规则</strong> </p>
<p>若属性（或属性组）F是基本关系 R 的外码 它与基本关系S 的主码Ks相对应（基本关系R和S不一定是不同的关系）， 则对于R中每个元组在F上的值必须为： </p>
<ul>
<li>或者取空值（F的每个属性值均为空值）</li>
<li>或者等于S中某个元组的主码值</li>
</ul>
<blockquote>
<p>[例2.1]中<br>学生关系中每个元组的“专业号”属性只取两类值：</p>
<ol>
<li>空值，表示尚未给该学生分配专业 </li>
<li>非空值，这时该值必须是专业关系中某个元组的“专业号”值，表示该学生不可能分配一个不存在的专业</li>
</ol>
</blockquote>
<h2 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h2><ul>
<li>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</li>
<li>关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能</li>
</ul>
<blockquote>
<p>课程（课程号，课程名，学分）</p>
<ul>
<li>“课程号”属性必须取唯一值</li>
<li>非主属性“课程名”也不能取空值 </li>
<li>“学分”属性只能取值{1，2，3，4}</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据库原理</category>
        <category>关系数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>关系演算</title>
    <url>/2022/04/20/%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>按谓词变元不同进行分类：</p>
<ol>
<li><p>元组关系演算： </p>
<p>以元组变量作为谓词变元的基本对象 </p>
<p>元组关系演算语言ALPHA</p>
</li>
<li><p>域关系演算： </p>
<p>以域变量作为谓词变元的基本对象 </p>
<p>域关系演算语言QBE</p>
</li>
</ol>
<span id="more"></span>

<h2 id="ALPHA语言"><a href="#ALPHA语言" class="headerlink" title="ALPHA语言"></a>ALPHA语言</h2><h3 id="检索语句"><a href="#检索语句" class="headerlink" title="检索语句"></a>检索语句</h3><blockquote>
<p>GET</p>
</blockquote>
<h4 id="1-简单检索"><a href="#1-简单检索" class="headerlink" title="(1) 简单检索"></a>(1) 简单检索</h4><p><code>GET 工作空间名（表达式1）</code></p>
<blockquote>
<p>eg.</p>
<p>[例2.14] 查询所有被选修的课程号码<br>     <code>GET W (SC.Cno)</code></p>
<p>[例2.15] 查询所有学生的数据<br>    <code>GET W (Student)</code></p>
</blockquote>
<h4 id="2-限定的检索"><a href="#2-限定的检索" class="headerlink" title="(2) 限定的检索"></a>(2) 限定的检索</h4><p><code>GET 工作空间名（表达式1）：操作条件</code></p>
<blockquote>
<p>eg.</p>
<p>[例2.16]查询信息系(IS)中年龄小于20岁的学生的学号和年龄<br><code>GET W (Student.Sno，Student.Sage): Student.Sdept=&#39;IS&#39;∧ Student.Sage&lt;20</code></p>
</blockquote>
<h4 id="3-带排序的检索"><a href="#3-带排序的检索" class="headerlink" title="(3) 带排序的检索"></a>(3) 带排序的检索</h4><p><code>GET 工作空间名（表达式1）[：操作条件] DOWN/UP 表达式2</code></p>
<blockquote>
<p>eg.</p>
<p>[例2.17]查询计算机科学系(CS)学生的学号、年龄，结果按年龄降序排序<br><code>GET W (Student.Sno，Student.Sage): Student.Sdept=&#39;CS&#39; DOWN Student.Sage</code></p>
</blockquote>
<h4 id="4-带定额的检索"><a href="#4-带定额的检索" class="headerlink" title="(4) 带定额的检索"></a>(4) 带定额的检索</h4><p><code>GET 工作空间名（定额）（表达式1） [：操作条件] [DOWN/UP 表达式2]</code></p>
<blockquote>
<p>eg.</p>
<p>[例2.18] 取出一个信息系学生的学号<br><code>GET W (1) (Student.Sno): Student.Sdept=&#39;IS&#39;</code></p>
<p>[例2.19] 查询信息系年龄最大的三个学生的学号及其年龄，结果按年龄降序排序<br><code>GET W (3) (Student.Sno，Student.Sage): Student.Sdept=&#39;IS&#39; DOWN Student.Sage</code></p>
</blockquote>
<p>(5) 用元组变量的检索</p>
<p>元组变量的用途：</p>
<ol>
<li>简化关系名：设一个较短名字的元组变量来代替较长的关系名。</li>
<li>操作条件中使用量词时必须用元组变量。</li>
</ol>
<blockquote>
<p>eg.</p>
<p>[例2.20] 查询信息系学生的名字<br><code>RANGE Student X  GET W (X.Sname): X.Sdept=‘IS&#39;</code></p>
</blockquote>
<p>(6) 用存在量词的检索</p>
<p>操作条件中使用量词时必须用元组变量</p>
<blockquote>
<p>eg</p>
<p>[例2.21] 查询选修2号课程的学生名字<br><code>RANGE SC X  GET W (Student.Sname):  ョX(X.Sno=Student.Sno∧X.Cno=&#39;2&#39;)</code></p>
<p>[例2.22] 查询选修了这样课程的学生学号，其直接先行课是6号课程。<br><code>RANGE Course CX GET W (SC.Sno): ョCX (CX.Cno=SC.Cno∧CX.Cpno=&#39;6&#39;)</code></p>
<p>[例2.23]查询至少选修一门其先行课为6号课程的学生名字</p>
<p><code>RANGE Course CX                 SC SCX GET W (Student.Sname): ョSCX (SCX.Sno=Student.Sno∧  ョCX (CX.Cno=SCX.Cno∧CX.Pcno=&#39;6&#39;))</code><br><em>前束范式形式：</em><br><code>GET W (Student.Sname):  ョSCXョCX (SCX.Sno=Student.Sno∧ CX.Cno=SCX.Cno∧CX.Pcno=&#39;6&#39;)</code></p>
</blockquote>
<h4 id="7-带有多个关系的表达式的检索"><a href="#7-带有多个关系的表达式的检索" class="headerlink" title="(7)带有多个关系的表达式的检索"></a>(7)带有多个关系的表达式的检索</h4><blockquote>
<p>eg.</p>
<p>[例2.24] 查询成绩为90分以上的学生名字与课程名字<br><code>RANGE SC SCX  GET W(Student.Sname，Course.Cname):  ョSCX (SCX.Grade≥90   ∧SCX.Sno=Student.Sno ∧ Course.Cno=SCX.Cno)</code></p>
<p>[例2.25] 查询不选1号课程的学生名字<br><code>RANGE SC SCX  GET W (Student.Sname):  ∀SCX ( SCX.Sno≠Student.Sno ∨ SCX.Cno≠&#39;1&#39; )</code><br><em>用存在量词表示：</em><br><code>RANGE SC SCX  GET W (Student.Sname): ┐∃SCX ( SCX.Sno=Student.Sno ∧ SCX.Cno=&#39;1&#39; )</code></p>
</blockquote>
<h4 id="9-用两种量词的检索"><a href="#9-用两种量词的检索" class="headerlink" title="(9)用两种量词的检索"></a>(9)用两种量词的检索</h4><blockquote>
<p>eg.</p>
<p>查询选修了全部课程的学生姓名<br><code>RANGE Course CX         SC SCX GET W (Student.Sname):  ∀CX ∃SCX ( SCX.Sno=Student.Sno ∧ SCX.Cno=CX.Cno )</code></p>
</blockquote>
<p>(10)用蕴含的检索</p>
<blockquote>
<p>eg.</p>
<p>[例2.27] 查询最少选修了201215122学生所选课程的学生学号<br><code>RANGE Couse CX  SC SCX  SC SCY  GET W (Student.Sno): ∀ CX ( ∃SCX (SCX.Sno=‘201215122&#39;∧SCX.Cno=CX.Cno)  → ∃SCY ( SCY.Sno = Student.Sno ∧ SCY.Cno = CX.Cno))</code></p>
</blockquote>
<p>(11)聚集函数</p>
<img src="image-20220504204756747.png" alt="image-20220504204756747" style="zoom:50%;" />

<blockquote>
<p>eg.</p>
<p>[例2.28] 查询学生所在系的数目<br><code>GET W ( COUNT(Student.Sdept) ) </code><br><em>COUNT函数在计数时会自动排除重复值。</em></p>
<p>[例2.29] 查询信息系学生的平均年龄<br><code>GET W (AVG(Student.Sage)): </code><br><code>Student.Sdept=&#39;IS&#39;</code></p>
</blockquote>
<h3 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h3><blockquote>
<p>PUT, HOLD, UPDATE, DELETE, DROP</p>
</blockquote>
<h4 id="修改-HOLD–修改–UPDATE"><a href="#修改-HOLD–修改–UPDATE" class="headerlink" title="修改 ( HOLD–修改–UPDATE )"></a>修改 ( HOLD–修改–UPDATE )</h4><blockquote>
<p>①用HOLD语句将要修改的元组从数据库中读到工作空间中<br>       HOLD 工作空间名（表达式1）[：操作条件 ]<br>       HOLD 语句是带上并发控制的GET语句</p>
<p>②用宿主语言修改工作空间中元组的属性 </p>
<p>③用UPDATE语句将修改后的元组送回数据库中<br>       UPDATE 工作空间名</p>
</blockquote>
<p>eg.</p>
<p>[例2.30] 把201215127学生从计算机科学系转到信息系</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HOLD</span> W (Student.Sno， Student.Sdept): Student.Sno<span class="operator">=</span><span class="string">&#x27;201215127&#x27;</span></span><br><span class="line"><span class="comment">-- 从Student关系中读出201215127学生的数据</span></span><br><span class="line">MOVE <span class="string">&#x27;IS&#x27;</span> <span class="keyword">TO</span> W.Sdept </span><br><span class="line"><span class="comment">-- 用宿主语言进行修改</span></span><br><span class="line"><span class="keyword">UPDATE</span> W </span><br><span class="line"><span class="comment">-- 把修改后的元组送回Student关系）</span></span><br></pre></td></tr></table></figure>

<h4 id="插入-建立新元组–PUT"><a href="#插入-建立新元组–PUT" class="headerlink" title="插入 ( 建立新元组–PUT )"></a>插入 ( 建立新元组–PUT )</h4><blockquote>
<p>①用宿主语言在工作空间中建立新元组 </p>
<p>②用PUT语句把该元组存入指定关系中<br>        PUT 工作空间名（关系名）</p>
<p><em>PUT语句只对一个关系操作，表达式为单个关系名</em></p>
</blockquote>
<p>eg.</p>
<p>[例2.31] 学校新开设了一门2学分的课程“计算机组织与结构”，其课程号为8，直接先行课为6号课程。插入该课程元组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MOVE <span class="string">&#x27;8&#x27;</span> <span class="keyword">TO</span> W.Cno </span><br><span class="line">MOVE <span class="string">&#x27;计算机组织与结构&#x27;</span> <span class="keyword">TO</span> W.Cname </span><br><span class="line">MOVE <span class="string">&#x27;6&#x27;</span> <span class="keyword">TO</span> W.Cpno </span><br><span class="line">MOVE <span class="string">&#x27;2&#x27;</span> <span class="keyword">TO</span> W.Ccredit </span><br><span class="line">PUT W (Course)</span><br></pre></td></tr></table></figure>



<h4 id="删除-HOLD–DELETE"><a href="#删除-HOLD–DELETE" class="headerlink" title="删除 ( HOLD–DELETE )"></a>删除 ( HOLD–DELETE )</h4><blockquote>
<p>①用HOLD语句把要删除的元组从数据库中读到工作空间中 </p>
<p>②用DELETE语句删除该元组<br>        DELETE 工作空间名</p>
</blockquote>
<p>eg.</p>
<p>[例2.32] 201215230学生因故退学，删除该学生元组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HOLD</span> W (Student): Student.Sno<span class="operator">=</span>‘<span class="number">201215230</span><span class="string">&#x27; </span></span><br><span class="line"><span class="string">DELETE W</span></span><br></pre></td></tr></table></figure>

<p>[例2.33] 将学号201215121改为201215122</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HOLD</span> W (Student): Student.Sno<span class="operator">=</span>‘<span class="number">201215121</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">DELETE W</span></span><br><span class="line"><span class="string">MOVE ‘201215122&#x27;</span> <span class="keyword">TO</span> W.Sno </span><br><span class="line">MOVE <span class="string">&#x27;李勇&#x27;</span> <span class="keyword">TO</span> W.Sname </span><br><span class="line">MOVE <span class="string">&#x27;男&#x27;</span> <span class="keyword">TO</span> W.Ssex </span><br><span class="line">MOVE <span class="string">&#x27;20&#x27;</span> <span class="keyword">TO</span> W.Sage </span><br><span class="line">MOVE <span class="string">&#x27;CS&#x27;</span> <span class="keyword">TO</span> W.Sdept </span><br><span class="line">PUT W (Student)</span><br></pre></td></tr></table></figure>

<p>[例2.34] 删除全部学生</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HOLD</span> W (Student) </span><br><span class="line"><span class="keyword">DELETE</span> W</span><br><span class="line"><span class="comment">-- 为保证参照完整性，删除Student中元组时相应地要删除SC中的元组 </span></span><br><span class="line"><span class="keyword">HOLD</span> W (SC) <span class="keyword">DELETE</span> W</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="QBE语言"><a href="#QBE语言" class="headerlink" title="QBE语言"></a>QBE语言</h2><ul>
<li>以元组变量的分量即域变量作为谓词变元的基本对象</li>
<li>QBE：Query By Example<ul>
<li>基于屏幕表格的查询语言</li>
<li>查询要求：以填写表格的方式构造查询</li>
<li>用示例元素(域变量)来表示查询结果可能的情况</li>
<li>查询结果：以表格形式显示</li>
</ul>
</li>
</ul>
<p>具体操作不进行赘述</p>
]]></content>
      <categories>
        <category>数据库原理</category>
        <category>关系数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>学生-课程数据库</title>
    <url>/2022/05/05/%E5%AD%A6%E7%94%9F-%E8%AF%BE%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
      <categories>
        <category>数据库原理</category>
        <category>关系数据库标准语言SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-作业一</title>
    <url>/2022/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BD%9C%E4%B8%9A%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一般操作系统中，进程的每个段内部地址均连续，但段与段的相对次序可能不同。<br>用C&#x2F;C++语言写一个小程序，探测一个操作系统中进程的各段的相对位置。<br>(输出次序即可)</p>
<p>截至日期：2022.4.14</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>       g_A = <span class="number">1</span>;    <span class="comment">//代码段， 常量</span></span><br><span class="line"><span class="type">int</span>             g_B = <span class="number">2</span>;	<span class="comment">//数据段， 全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span>      g_C;		<span class="comment">//BSS段， 未初始化全局静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddStruct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> add;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmpare</span><span class="params">(<span class="type">const</span> AddStruct&amp; a, <span class="type">const</span> AddStruct&amp; b)</span><span class="comment">//const必须加,不然会错 当return的是ture时, a先输出, 所以示例中是升序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.add &lt; b.add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> 	<span class="comment">//栈，函数参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_A;					    <span class="comment">//栈，局部变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> local_B = <span class="number">4</span>;			    <span class="comment">//数据段，局部静态变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> local_C;				    <span class="comment">//BSS段，未初始化局部静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* p2 = <span class="string">&quot;123456&quot;</span>;			    <span class="comment">//“123456”在代码段，</span></span><br><span class="line">                                        <span class="comment">//字符串常量， P2在栈上</span></span><br><span class="line">    <span class="type">char</span>* g_p1 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);	    <span class="comment">//申请的10字节空间在堆上</span></span><br><span class="line"></span><br><span class="line">    AddStruct MyStruct[<span class="number">5</span>];</span><br><span class="line">    MyStruct[<span class="number">0</span>].name = <span class="string">&quot;Code&quot;</span>;</span><br><span class="line">    MyStruct[<span class="number">0</span>].add = <span class="keyword">reinterpret_cast</span> &lt;<span class="type">long</span> <span class="type">long</span>&gt;(&amp;main);</span><br><span class="line"></span><br><span class="line">    MyStruct[<span class="number">1</span>].name = <span class="string">&quot;Data&quot;</span>;</span><br><span class="line">    MyStruct[<span class="number">1</span>].add = <span class="keyword">reinterpret_cast</span> &lt;<span class="type">long</span> <span class="type">long</span>&gt;(&amp;g_B);</span><br><span class="line"></span><br><span class="line">    MyStruct[<span class="number">2</span>].name = <span class="string">&quot;BSS&quot;</span>;</span><br><span class="line">    MyStruct[<span class="number">2</span>].add = <span class="keyword">reinterpret_cast</span> &lt;<span class="type">long</span> <span class="type">long</span>&gt;(&amp;g_C);</span><br><span class="line"></span><br><span class="line">    MyStruct[<span class="number">3</span>].name = <span class="string">&quot;Stack&quot;</span>;</span><br><span class="line">    MyStruct[<span class="number">3</span>].add = <span class="keyword">reinterpret_cast</span> &lt;<span class="type">long</span> <span class="type">long</span>&gt;(p2);</span><br><span class="line"></span><br><span class="line">    MyStruct[<span class="number">4</span>].name = <span class="string">&quot;Heap&quot;</span>;</span><br><span class="line">    MyStruct[<span class="number">4</span>].add = <span class="keyword">reinterpret_cast</span> &lt;<span class="type">long</span> <span class="type">long</span>&gt;(&amp;g_p1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="built_in">sort</span>(MyStruct, MyStruct+ <span class="number">5</span>, Cmpare);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>)&lt;&lt; MyStruct[i].name &lt;&lt; <span class="string">&quot;Segment 的 address 为: &quot;</span> &lt;&lt; MyStruct[i].add &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
        <category>作业</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-作业三</title>
    <url>/2022/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BD%9C%E4%B8%9A%E4%B8%89/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>go语言是一门非常优秀的语言，go语言最大的特色就是从语言层面支持并发(Goroutine)，<br>调研Goroutine的底层原理，形成研究报告</p>
<p>截止时间：2022-04-28</p>
<span id="more"></span>

<h2 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h2><p>线程的实现可以分三类：用户级线程，内核级线程和混合式线程。</p>
<h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p><em>用户级线程</em>是指 不需要内核支持而在用户程序中实现的线程，它的内核的切换是由用户态程序自己控制内核的切换，不需要内核的干涉。但是它不能像内核级线程一样更好的运用多核CPU。</p>
<p>库调度器从进程的多个线程中选择一个线程，然后该线程和该进程允许的一个内核线程关联起来。内核线程将被操作系统调度器指派到处理器内核。</p>
<p>用户级线程是一种 <strong>多对一</strong> 的线程映射。</p>
<img src="操作系统-作业三/image-20220427223139161.png" alt="image-20220427223139161" style="zoom:67%;" />

<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>内核级线程:切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态。可以很好的运用多核CPU，就像Windows电脑的四核八线程，双核四线程一样。</p>
<p>内核线程驻留在内核空间，它们是内核对象。有了内核线程，每个用户线程被映射或绑定到一个内核线程。用户线程在其生命期内都会绑定到该内核线程。一旦用户线程终止，两个线程都将离开系统。</p>
<p>这被称作<strong>一对一</strong>线程映射。</p>
<img src="操作系统-作业三/image-20220427223238224.png" alt="image-20220427223238224" style="zoom:67%;" />

<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>通常goroutine会被当做coroutine（<strong>协程</strong>）的 golang实现。<br>goroutine和它的Go Scheduler在底层实现上其实是属于混合型线程，goroutine并不等同于协程。</p>
<p>组合方式的多线程实现, 线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行. 一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。</p>
<p>下图说明了用户级与内核级的组合实现方式, 在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合</p>
<img src="操作系统-作业三/image-20220427223334547.png" alt="image-20220427223334547" style="zoom: 60%;" />



<h2 id="goroutine的内存分配"><a href="#goroutine的内存分配" class="headerlink" title="goroutine的内存分配"></a>goroutine的内存分配</h2><p>每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，而对于一些复杂的任务（如深度嵌套的递归）来说又显得太小。因此，Go语言做了它自己的『线程』。</p>
<p>在Go语言中，每一个goroutine是一个独立的执行单元，相较于每个OS线程固定分配2M内存的模式，goroutine的栈采取了动态扩容方式， 初始时仅为2KB，随着任务执行按需增长，最大可达1GB，且完全由golang自己的调度器 Go Scheduler 来调度。此外，GC还会周期性地将不再使用的内存回收，收缩栈空间。</p>
<h2 id="G-P-M-模型"><a href="#G-P-M-模型" class="headerlink" title="G-P-M 模型"></a>G-P-M 模型</h2><ul>
<li>G: 表示Goroutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。G并非执行体，每个G需要绑定到P才能被调度执行。</li>
<li>P: Processor，表示逻辑处理器， 对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，<strong>P的数量决定了系统内最大可并行的G的数量</strong>（前提：物理CPU核数 &gt;&#x3D; P的数量），P的数量由用户设置的GOMAXPROCS决定，但是不论GOMAXPROCS设置为多大，P的数量最大为256。</li>
<li>M: Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环；而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M，如此反复。M并不保留G状态，这是G可以跨M调度的基础，M的数量是不定的，由Go Runtime调整，为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个。</li>
</ul>
<img src="操作系统-作业三/image-20220427223558868.png" alt="image-20220427223558868" style="zoom:67%;" />

<p>Go调度器工作时会维护两种用来保存G的任务队列：一种是一个Global任务队列，一种是每个P维护的Local任务队列。</p>
<p>当通过go关键字创建一个新的goroutine的时候，它会优先被放入P的本地队列。为了运行goroutine，M需要持有（绑定）一个P，接着M会启动一个OS线程，循环从P的本地队列里取出一个goroutine并执行。还有work-stealing调度算法：当M执行完了当前P的Local队列里的所有G后，P也不会什么都不干，它会先尝试从Global队列寻找G来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里中拿走一半的G到自己的队列中执行。</p>
]]></content>
  </entry>
  <entry>
    <title>操作系统-作业二</title>
    <url>/2022/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BD%9C%E4%B8%9A%E4%BA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>实现一程序，分别在Windows、Linux操作系统下验证:</p>
<ul>
<li>栈、堆、数据区是否可读可写不可执行</li>
<li>代码段是否可读可执行不可写</li>
</ul>
<p>截止时间：2022.4.22</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据段</span></span><br><span class="line"><span class="type">int</span> DataArea;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Stack</span><span class="params">( <span class="type">int</span> x )</span>    <span class="comment">//代码段</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> StackArea;      <span class="comment">//栈</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;StackValue   &quot;</span>&lt;&lt;StackArea&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;HeapAddress &quot;</span>&lt;&lt;&amp;StackArea&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Readable&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Trying writing... &quot;</span>&lt;&lt;endl;</span><br><span class="line">    *(&amp;StackArea) = <span class="number">12</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Value after change: &quot;</span>&lt;&lt;StackArea&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Writable&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CodeArea</span><span class="params">( <span class="type">int</span> y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;CodeArea is executing&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Ending...&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ch = <span class="number">1</span>;</span><br><span class="line">    <span class="type">float</span> time_use=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> start;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> end;<span class="comment">//struct timezone tz;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* p;</span><br><span class="line">    <span class="type">char</span>* HeapArea = ( <span class="type">char</span>* ) <span class="built_in">malloc</span> ( <span class="built_in">sizeof</span>( <span class="type">char</span> ) );  <span class="comment">//堆段</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( ch != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;_______________________________________________________________________&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;please select: &quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;1.DataSegment    2.CodeSegment   3.StackSegment  4.HeapSegment   0.exit&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;_______________________________________________________________________&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ch == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//dataseg</span></span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;DataValue   &quot;</span>&lt;&lt;DataArea&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;DataAddress &quot;</span>&lt;&lt;&amp;DataArea&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Readable&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Trying writing... &quot;</span>&lt;&lt;endl;</span><br><span class="line">            *(&amp;DataArea) = <span class="number">21</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Value after change: &quot;</span>&lt;&lt;DataArea&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Writable&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( ch == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//codeseg</span></span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;CodeValue   &quot;</span>&lt;&lt;CodeArea&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;CodeAddress &quot;</span>&lt;&lt;&amp;CodeArea&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Readable&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Trying writing... &quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="comment">//*(&amp;CodeArea) = 21;</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;CodeBlocks warning-&gt; error: assignment of read-only location &#x27;* CodeArea&#x27;|&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Unwritable&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Now execute-&gt; &quot;</span>&lt;&lt;endl;</span><br><span class="line">            (<span class="built_in">void</span> (*)())&amp;CodeArea;<span class="comment">//将地址转换为函数指针运行</span></span><br><span class="line">            (*(<span class="built_in">void</span> (*)())&amp;CodeArea)();</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;&lt;- Executable&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( ch == <span class="number">3</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//stackseg</span></span><br><span class="line">            <span class="built_in">Stack</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( ch == <span class="number">4</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//heapseg</span></span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;HeapValue   &quot;</span>&lt;&lt;HeapArea&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;HeapAddress &quot;</span>&lt;&lt;&amp;HeapArea&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Readable&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Trying writing... &quot;</span>&lt;&lt;endl;</span><br><span class="line">            *(&amp;HeapArea) = <span class="string">&quot;HEAP&quot;</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Value after change: &quot;</span>&lt;&lt;DataArea&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Writable&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( ch == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
        <category>作业</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统概述</title>
    <url>/2022/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
      <categories>
        <category>操作系统</category>
        <category>操作系统引论</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统概述</title>
    <url>/2022/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>1-1数据库系统概论，概念较多</p>
<span id="more"></span>

<h2 id="数据库的四个基本概念"><a href="#数据库的四个基本概念" class="headerlink" title="数据库的四个基本概念"></a>数据库的四个基本概念</h2><h3 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据(Data)"></a>数据(Data)</h3><ul>
<li>描述事物的符号记录</li>
<li>数据是数据库中存储的基本对象</li>
<li>数据的含义称为数据的语义，数据与其语义是不可分的</li>
</ul>
<h3 id="数据库-DataBase"><a href="#数据库-DataBase" class="headerlink" title="数据库(DataBase)"></a>数据库(DataBase)</h3><ul>
<li><em>长期储存</em>在计算机内、<em>有组织</em>的、<em>可共享</em>的大量数据的集合</li>
<li>基本特征：<ul>
<li>数据按一定的数据模型组织、描述和储存</li>
<li>可为各种用户共享</li>
<li>冗余度较小</li>
<li>数据独立性较高</li>
<li>易扩展</li>
</ul>
</li>
</ul>
<h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><ul>
<li>位于用户与操作系统之间的一层数据管理软件</li>
<li>科学地组织和存储数据、高效地获取和维护数据</li>
<li>主要功能<ul>
<li>数据定义功能<ul>
<li>提供数据定义语言（DDL）</li>
<li>定义数据库中的数据对象</li>
</ul>
</li>
<li>数据组织、存储和管理<ul>
<li>分类组织、存储和管理各种数据</li>
<li>确定组织数据的文件结构和存取方式</li>
<li>实现数据之间的联系</li>
<li>提供多种存取方法提高效率</li>
</ul>
</li>
<li>数据操纵功能<ul>
<li>提供数据操纵语言（DML）</li>
<li>实现对数据库的基本操作（查，插，删，改）</li>
</ul>
</li>
<li>数据库的事务管理和运行管理<ul>
<li>数据库在 <em>建立 运行 维护</em> 时，由数据库管理系统统一管理和控制</li>
<li>保证数据的 <em>安全性 完整性 多用户对数据的并发使用</em></li>
<li>发生故障后的系统修复</li>
</ul>
</li>
<li>数据库的建立和维护功能<ul>
<li>数据库初始数据的 <em>装载和维护</em></li>
<li>数据库 <em>转储 恢复</em> 功能</li>
<li>数据库的 <em>重组织</em></li>
<li>性能监视分析等</li>
</ul>
</li>
<li>其他功能<ul>
<li>数据库管理功能 和 网络中其他软件系统的<em>通信</em></li>
<li>数据库管理系统之间的<em>数据转换</em></li>
<li>异构数据库之间的<em>互访和互操作</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据库系统-DataBase-System"><a href="#数据库系统-DataBase-System" class="headerlink" title="数据库系统(DataBase System)"></a>数据库系统(DataBase System)</h3><ul>
<li>由 <em>数据库 + 数据库管理系统（及其应用开发工具）+应用程序+数据库管理员</em> 构成</li>
</ul>
<img src="数据库系统结构.png" style="zoom:40%;" />

<h2 id="数据库管理技术的产生和发展"><a href="#数据库管理技术的产生和发展" class="headerlink" title="数据库管理技术的产生和发展"></a>数据库管理技术的产生和发展</h2><h3 id="数据库管理系统的发展过程"><a href="#数据库管理系统的发展过程" class="headerlink" title="数据库管理系统的发展过程"></a>数据库管理系统的发展过程</h3><ul>
<li>人工管理阶段</li>
<li>文件管理阶段</li>
<li>数据库管理阶段</li>
</ul>
<h2 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h2><h3 id="数据结构化"><a href="#数据结构化" class="headerlink" title="数据结构化"></a>数据结构化</h3><ul>
<li>不针对某一应用，面向全组织</li>
<li>整体结构化，数据间有联系</li>
<li>数据记录可以变长</li>
<li>数据的最小存取单位是<em>数据项</em></li>
</ul>
<h3 id="数据共享性高、冗余性低且易扩充"><a href="#数据共享性高、冗余性低且易扩充" class="headerlink" title="数据共享性高、冗余性低且易扩充"></a>数据共享性高、冗余性低且易扩充</h3><ul>
<li>数据面向整个系统，被共享使用</li>
<li>优点<ul>
<li>减少数据冗余，节约存储空间</li>
<li>避免数据之间的不相容性&amp;不一致性</li>
<li>使系统容易扩充</li>
</ul>
</li>
</ul>
<h3 id="数据独立性高"><a href="#数据独立性高" class="headerlink" title="数据独立性高"></a>数据独立性高</h3><ul>
<li><p>物理独立性</p>
<p>指<em>用户的 应用程序</em> 与 <em>数据库中数据的物理存储</em> 是相互 独立的</p>
</li>
<li><p>逻辑独立性</p>
<p>指 <em>用户的应用程序</em> 与 <em>数据库的逻辑结构</em> 是相互独立的</p>
</li>
<li><p>数据独立性由数据库管理系统的 <em>二级映像</em>  功能来保证</p>
</li>
</ul>
<h3 id="数据由数据库管理系统统一管理控制"><a href="#数据由数据库管理系统统一管理控制" class="headerlink" title="数据由数据库管理系统统一管理控制"></a>数据由数据库管理系统统一管理控制</h3><p>数据库管理系统要提供数据控制功能</p>
<ul>
<li>security 安全性保护</li>
<li>integrity 完整性检查</li>
<li>concurrency 并发控制</li>
<li>recovery 数据库恢复</li>
</ul>
<h2 id="数据库概念小结"><a href="#数据库概念小结" class="headerlink" title="数据库概念小结"></a>数据库概念小结</h2><ul>
<li><p><strong>数据库</strong> 是  <em>长期存储</em>  在计算机内<em>有组织的</em>  <em>大量的</em>  <em>共享的</em>  数据集合</p>
</li>
<li><p>可以为多种用户所<strong>共享</strong>，具有  <em>较小冗余度</em>  和  <em>较高数据独立性</em></p>
</li>
<li><p>数据库管理系统 在 数据库 <em>建立、运用和维护</em>  时对数据库进行统一控制：</p>
<p>保证数据的 <em>完整性</em>、<em>安全性</em>，</p>
<p>并在多用户同时使用数据库时进行<em>并发控制</em>，</p>
<p>在发生故障后对数据库进行<em>恢复</em>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库原理</category>
        <category>绪论</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据模型</title>
    <url>/2022/04/18/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>数据模型是对现实世界数据特征的抽象。（通俗地讲数据模型就是现实世界的模拟）<br>数据模型是数据库系统的核心和基础<br>数据模型应满足三方面要求：<br>        能比较真实地模拟现实世界 ; 容易为人所理解 ; 便于在计算机上实现. </p>
<span id="more"></span>

<h2 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h2><h3 id="概念模型-信息模型"><a href="#概念模型-信息模型" class="headerlink" title="概念模型(信息模型)"></a>概念模型(信息模型)</h3><p>按照用户的观点来对数据和信息建模，用于数据库设计。</p>
<h3 id="逻辑模型和物理模型"><a href="#逻辑模型和物理模型" class="headerlink" title="逻辑模型和物理模型"></a>逻辑模型和物理模型</h3><ul>
<li><p>逻辑模型主要包括：</p>
<p>网状模型、层次模型、关系模型、面向对象模型、对象关系数据模型、半结构化数据模型等</p>
<p>按照计算机系统的观点对数据建模，用于DBMS实现</p>
</li>
<li><p>物理模型</p>
<p>是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</p>
</li>
</ul>
<img src="两类模型.png" style="zoom: 50%;" />

<h2 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h2><p><strong>用途</strong>：用于信息世界的建模；现实世界到机器世界的一个中间层次；数据库设计的工具；数据库设计人员和用户之间进行交流的语言。</p>
<p><strong>基本要求</strong>：<br>    较强的语义表达能力；<br>    简单、清晰、易于用户理解。</p>
<p><em>信息世界中的基本概念：</em></p>
<ul>
<li><p><strong>实体(entity)</strong></p>
<p>客观存在并可相互区别的事物称为实体。（具体的人、事、物or抽象的概念）</p>
</li>
<li><p><strong>属性(attribute)</strong></p>
<p>实体所具有的某一特性。（一个实体可以由多个属性刻画）</p>
</li>
<li><p><strong>码(key)</strong></p>
<p>唯一标识实体的属性集称为码。</p>
</li>
<li><p><strong>实体型(entity type)</strong></p>
<p>用实体名及其属性名集合 来抽象和刻画同类实体称为实体型。</p>
</li>
<li><p><strong>实体集(entity set)</strong></p>
<p>同一类型实体的集合。</p>
</li>
<li><p><strong>联系(relationship)</strong></p>
<p>现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系；</p>
<p><strong>实体内部的联系</strong>通常是指组成实体的各属性之间的联系</p>
<p><strong>实体之间的联系</strong>通常是指不同实体集之间的联系</p>
<p>实体之间的联系有<em>一对一、一对多、多对多</em> 等多种类型</p>
</li>
</ul>
<p>概念模型的一种表示方法：<strong>实体-联系方法</strong> ( Entity-Relationship Approach )</p>
<p>​        用<strong>E-R图</strong>来描述现实世界的概念模型（E-R方法也称为E-R模型）</p>
<h2 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h2><ul>
<li><p><strong>数据结构</strong></p>
<p>描述数据库的组成对象，以及对象之间的联系；</p>
<p>数据结构是对系统静态特性的描述。</p>
</li>
<li><p><strong>数据操作</strong></p>
<p>操作即集合，包括操作及有关的操作规则；</p>
<p>数据操作的类型：查询，更新（包括插、删、改）</p>
<p><em><strong>数据模型对操作的定义：</strong></em></p>
<blockquote>
<p>操作的确切含义<br>操作符号<br>操作规则（eg. 优先级）<br>实现操作的语言</p>
</blockquote>
<p><em>数据操作使对系统动态特性的描述</em></p>
</li>
<li><p><strong>数据的完整性约束条件</strong></p>
<p><strong>完整性规则</strong>给定的数据模型中数据及其联系所具有的制约和依存规则。</p>
<p>用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。</p>
<p><em><strong>数据模型对完整性约束条件的定义</strong></em></p>
<blockquote>
<p>反映和规定必须遵守的基本的通用的完整性约束条件。</p>
<p>提供完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。</p>
</blockquote>
</li>
</ul>
<h2 id="常用的数据模型"><a href="#常用的数据模型" class="headerlink" title="常用的数据模型"></a>常用的数据模型</h2><ul>
<li><p>层次模型</p>
</li>
<li><p>网状模型</p>
</li>
<li><p>关系模型</p>
</li>
<li><p>面向对象数据模型</p>
</li>
<li><p>对象关系数据模型</p>
</li>
<li><p>半结构化数据模型</p>
</li>
</ul>
<p><strong>格式化模型</strong></p>
<p>​    层次模型和网状模型统称为 <strong>格式化模型</strong></p>
<p>​    格式化模型中数据结构的单位是 <strong>基本层次联系</strong></p>
<p>​        <strong>基本层次联系</strong>是指两个记录以及它们之间的一对多的联系</p>
<h2 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h2><p> 层次模型用 <strong>树状结构</strong>来表示各类实体以及实体间的联系。</p>
<p>满足下面两个条件的基本层次联系的集合为层次模型：</p>
<ol>
<li>有且只有一个结点没有双亲结点-根结点</li>
<li>根以外的其它结点有且只有一个双亲结点</li>
</ol>
<img src="层次模型.png" style="zoom:50%;" />

<p>层次模型的<strong>特点</strong>：</p>
<blockquote>
<p>结点的双亲是唯一的<br>只能直接处理一对多的实体联系<br>每个记录类型可以定义一个排序字段，称为码字段<br>任何记录值只有按其路径查看时，才能显出它的全部意义<br>没有一个子女记录值能够脱离双亲记录而独立存在</p>
</blockquote>
<p>层次模型的<strong>数据操纵</strong>：</p>
<blockquote>
<p>查询、插入、删除、更新</p>
</blockquote>
<p>层次模型的<strong>完整性约束条件</strong></p>
<blockquote>
<p>无相应的双亲结点值就不能插入子女结点值</p>
<p>如果删除双亲结点值，则相应的子女结点值也被同时删除</p>
<p>更新操作时，应更新所有相应记录，以保证数据的一致性</p>
</blockquote>
<p>层次模型的<strong>优缺点</strong>：<br>        <em>优点</em></p>
<blockquote>
<p>数据结构简单清晰</p>
<p>查询效率高，性能优于关系模型，不低于网状模型</p>
<p>提供了良好的完整性支持</p>
</blockquote>
<p>​        <em>缺点</em></p>
<blockquote>
<p>结点之间的多对多联系表示不自然</p>
<p>插入和删除操作的限制多，应用程序的编写复杂</p>
<p>查询子女结点必须通过双亲结点</p>
<p>层次命令趋于程序化</p>
</blockquote>
<h2 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h2><p>满足下面两个条件的基本层次联系的集合：</p>
<ol>
<li>允许一个以上的结点无双亲</li>
<li>一个结点可以有多于一个的双亲</li>
</ol>
<p>网状模型与层次模型的区别：</p>
<blockquote>
<p>网状模型允许多个结点没有双亲结点</p>
<p>网状模型允许结点有多个双亲结点</p>
<p>网状模型允许两个结点之间有多种联系（复合联系）</p>
<p>网状模型可以更直接地描述现实世界</p>
<p>层次模型是网状模型的一个特例</p>
</blockquote>
<p>网状模型的操纵与完整性约束：</p>
<blockquote>
<p>码：唯一表示记录的数据项的集合</p>
<p>一个联系中双亲记录与子女记录之间是一对多联系</p>
<p>支持双亲记录和子女记录之间某些约束条件</p>
</blockquote>
<p>网状模型的优缺点：</p>
<p>​        <em>优点：</em></p>
<blockquote>
<p>能够更为直接地描述现实世界，如一个结点可以有多个双亲</p>
<p>具有良好的性能，存取效率较高</p>
</blockquote>
<p>​        <em>缺点：</em></p>
<blockquote>
<p>结构较为复杂。且随着应用环境的扩大，数据库的结构更加复杂，不利于最终用户掌握</p>
<p>DDL、DML语言复杂，用户不容易使用</p>
<p>记录之间联系是通过存取路径实现的，用户必须了解系统结构的细节</p>
</blockquote>
<h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p>关系模型的数据结构：</p>
<ul>
<li><p>关系（relation）</p>
<p>一个关系对应通常说的一张表</p>
</li>
<li><p>元组（tuple）</p>
<p>表中的一行即为一个元组</p>
</li>
<li><p>属性（attribute）</p>
<p>表中的一列即为属性，给每个属性起一个名称即属性名</p>
</li>
<li><p>主码（码键）</p>
<p>表中的某个属性组，可以唯一确定一个元组</p>
</li>
<li><p>域（domain）</p>
<p>是一组具有相同数据类型的值的集合。属性的取值范围来自某个域</p>
</li>
<li><p>分量</p>
<p>元组中的一个属性值</p>
</li>
<li><p>关系模式</p>
<p>对关系的描述</p>
</li>
</ul>
<p>关系必须是规范化的，满足一定的规范条件<br>        最基本的规范条件：关系的每一个分量必须是一个不可分的数据项，不允许表        中还有表。</p>
<p>关系模型的操纵：<br>        数据操作是集合操作，操作对象和操作结果都是关系<br>        <code>查询</code>  <code>插入</code>  <code>删除</code>  <code>更新</code>  </p>
<p>关系的完整性约束条件：</p>
<ul>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户定义的完整性</li>
</ul>
<p>关系模型的优缺点：</p>
<p>​        <em>优点：</em></p>
<blockquote>
<p>建立在严格的数学概念的基础上</p>
<p>概念单一<br>        实体和各类联系都用关系来表示<br>        对数据的检索结果也是关系</p>
<p>关系模型的存取路径对用户透明<br>        具有更高的数据独立性，更好的安全保密性<br>        简化了程序员的工作和数据库开发建立的工作</p>
</blockquote>
<p>​        <em>缺点：</em></p>
<blockquote>
<p>存取路径对用户透明，查询效率不如格式化数据模型</p>
<p>为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的难度</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库原理</category>
        <category>绪论</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统结构和组成</title>
    <url>/2022/04/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%92%8C%E7%BB%84%E6%88%90/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>❖从数据库应用开发人员角度看，数据库系统通常采用三级 模式结构，是数据库系统内部的系统结构</p>
<p>❖从数据库最终用户角度看，数据库系统的结构分为: - 单用户结构 - 主从式结构 - 分布式结构 -客户-服务器 等</p>
<p>❖数据库的组成: 数据库 + 数据库管理系统（及其开发工具）+ 应用程序 + 数据库管理员</p>
<span id="more"></span>

<h2 id="数据库系统模式的概念"><a href="#数据库系统模式的概念" class="headerlink" title="数据库系统模式的概念"></a>数据库系统模式的概念</h2><h3 id="型（type）"><a href="#型（type）" class="headerlink" title="型（type）"></a>型（type）</h3><p>对某一类数据的结构和属性的说明</p>
<h3 id="值（value）"><a href="#值（value）" class="headerlink" title="值（value）"></a>值（value）</h3><p>是型的一个具体赋值</p>
<blockquote>
<p>eg.<br>学生记录：<br>（学号，姓名，性别，系别，年龄，籍贯）</p>
<p>一个记录值：<br>（201315130，李明，男，计算机系，19，江苏南京市）</p>
</blockquote>
<h3 id="模式（schema）"><a href="#模式（schema）" class="headerlink" title="模式（schema）"></a>模式（schema）</h3><ul>
<li>数据库逻辑结构和特征的描述</li>
<li>是型的描述，不涉及具体值</li>
<li>反映的是数据的结构及其联系</li>
<li>模式是相对稳定的</li>
</ul>
<h3 id="实例（instance）"><a href="#实例（instance）" class="headerlink" title="实例（instance）"></a>实例（instance）</h3><ul>
<li>模式的一个具体值</li>
<li>反映数据库某一时刻的状态</li>
<li>同一个模式可以有很多实例</li>
<li>实例随数据库中的数据的更新而变动</li>
</ul>
<h2 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h2><img src="三级模式.png" style="zoom:50%;" />

<h3 id="模式（逻辑模式）"><a href="#模式（逻辑模式）" class="headerlink" title="模式（逻辑模式）"></a>模式（逻辑模式）</h3><ul>
<li>数据库中全体数据的逻辑结构和特征的描述</li>
<li>所有用户的公共数据视图</li>
<li>一个数据库只有一个模式</li>
<li><em>是数据库系统模式结构的中间层</em><ul>
<li>与数据的物理存储细节和硬件环境无关</li>
<li>与具体的应用程序、开发工具及高级程序设计语言无关</li>
</ul>
</li>
</ul>
<p>模式的定义：</p>
<ul>
<li>数据的逻辑结构（数据项的名字、类型、取值范围等）</li>
<li>数据之间的联系</li>
<li>数据有关的安全性、完整性要求</li>
</ul>
<h3 id="外模式（子模式OR用户模式）"><a href="#外模式（子模式OR用户模式）" class="headerlink" title="外模式（子模式OR用户模式）"></a>外模式（子模式OR用户模式）</h3><ul>
<li><p>数据库用户使用的局部数据的逻辑结构和特征的描述</p>
</li>
<li><p>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</p>
</li>
<li><p><em>介于模式与应用之间</em></p>
<ul>
<li><p>模式与外模式的关系：一对多</p>
<blockquote>
<p>外模式通常是模式的子集</p>
<p>一个数据库可以有多个外模式</p>
<p>对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同</p>
</blockquote>
</li>
<li><p>外模式与应用的关系：一对多</p>
<blockquote>
<p>同一外模式也可以为某一用户的多个应用系统所使用</p>
<p>但一个应用程序只能使用一个外模式</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>外模式的用途</p>
<ul>
<li>保证数据库安全性</li>
<li>每个用户只能看见和访问所对应的外模式中的数据</li>
</ul>
<h3 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h3><ul>
<li>是数据物理结构和存储方式的描述</li>
<li>是数据在数据库内部的表示方式</li>
<li>一个数据库只有一个内模式</li>
</ul>
<h2 id="数据库的二级印象功能与数据独立性"><a href="#数据库的二级印象功能与数据独立性" class="headerlink" title="数据库的二级印象功能与数据独立性"></a>数据库的二级印象功能与数据独立性</h2><p><strong>三级模式</strong>是对数据的三个抽象级别</p>
<p><strong>二级映像</strong>在数据库管理系统内部实现这三个抽象层次的联系和转换</p>
<p><code>外模式/模式 映像</code>&amp; <code>模式/内模式 映像</code></p>
<h3 id="外模式-x2F-模式-映像"><a href="#外模式-x2F-模式-映像" class="headerlink" title="外模式&#x2F;模式 映像"></a>外模式&#x2F;模式 映像</h3><p><strong>模式：</strong>描述的是数据的 <code>全局</code> 逻辑结构</p>
<p><strong>外模式：</strong>描述的是数据的 <code>局部</code> 逻辑结构</p>
<ul>
<li>同一个模式可以有任意多个外模式</li>
<li>每一个外模式，数据库系统都有一个<code>外模式/模式 映像</code>，定义外模式与模式之间的对应关系映像定义通常包含在各自外模式的描述中</li>
<li><em>保证数据的逻辑独立性</em><ul>
<li>模式改变时，数据库管理员对<code>外模式/模式</code>作相应改变，使外模式保持不变</li>
<li>应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性（数据的逻辑独立性）</li>
</ul>
</li>
</ul>
<h3 id="模式-x2F-内模式-映像"><a href="#模式-x2F-内模式-映像" class="headerlink" title="模式&#x2F;内模式 映像"></a>模式&#x2F;内模式 映像</h3><ul>
<li><p>模式／内模式映象是唯一的，定义了数据全局逻辑结构与 存储结构之间的对应关系。</p>
</li>
<li><p>映象定义通常包含在模式描述中</p>
</li>
<li><p><em>保证数据的物理独立性</em></p>
<ul>
<li>当数据库的存储结构改变了（例如选用了另一种存储结构，数据库管理员修改模式／内模式映象，使模式保持不变。</li>
<li>应用程序不受影响。保证了数据与程序的物理独立性， 简称数据的物理独立性。</li>
</ul>
</li>
</ul>
<h3 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h3><ul>
<li>全局逻辑结构，是数据库的中心与关键</li>
<li>独立于数据库的其他层次</li>
<li>设计数据库模式结构时应首先确定数据库的逻辑模式</li>
</ul>
<h3 id="数据库的内模式"><a href="#数据库的内模式" class="headerlink" title="数据库的内模式"></a>数据库的内模式</h3><ul>
<li>依赖于它的全局逻辑结构</li>
<li>独立于数据库的用户视图（外模式）</li>
<li>独立于具体的存储设备</li>
<li>将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率</li>
</ul>
<h3 id="数据库的外模式"><a href="#数据库的外模式" class="headerlink" title="数据库的外模式"></a>数据库的外模式</h3><ul>
<li>面向具体二点应用程序</li>
<li>定义在逻辑模式之上</li>
<li>独立于存储模式和存储设备</li>
<li>当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动</li>
<li>设计外模式时应充分考虑到应用的扩充性</li>
</ul>
<h3 id="数据库的二级映像"><a href="#数据库的二级映像" class="headerlink" title="数据库的二级映像"></a>数据库的二级映像</h3><ul>
<li>保证了数据库外模式的稳定性</li>
<li>从底层保证了应用程序的稳定性</li>
</ul>
<h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><blockquote>
<p>数据库<br>数据库管理系统<br>应用程序<br>数据库管理员</p>
</blockquote>
<p>还包括：</p>
<blockquote>
<p><strong>硬件平台及数据库</strong></p>
<ul>
<li>内存大 </li>
<li>足够大的磁盘存放数据库和数据备份</li>
<li>要求系统有较高的通道能力，提高数据传送率</li>
</ul>
</blockquote>
<blockquote>
<p><strong>软件</strong></p>
<ul>
<li>数据库管理系统</li>
<li>支持数据库管理系统运行的操作系统</li>
<li>与数据库接口的高级语言及其编译系统</li>
<li>以数据库管理系统为核心的应用开发工具</li>
<li>为特定应用环境开发的数据库应用系统</li>
</ul>
</blockquote>
<blockquote>
<p><strong>人员</strong></p>
<ul>
<li>数据库管理员</li>
<li>系统分析员和数据库设计人员</li>
<li>应用程序员</li>
<li>最终用户</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据库原理</category>
        <category>绪论</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>进程概述</title>
    <url>/2022/04/12/%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
      <categories>
        <category>操作系统</category>
        <category>进程的描述与控制</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>正确吵架</title>
    <url>/2022/04/10/%E6%AD%A3%E7%A1%AE%E5%90%B5%E6%9E%B6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="007619e2454b128b868ec7a215d3569c417e7e08738ad0e6fd8137b256137a44">125d5861506b304b03688d1b4cb724cc2efcf53d80f0914c03525b008e414d7c680919db81a95232f64c0d1d950f83b47c7627d91b112542de85efc725778622c2a87fc87c8c7c739c141dcc1b748e47e21cca03c303d52fcb11d09b684208d2abb3806b930df77982a622e8fa34ffde4438b3c3997040ff8f2fb88dcbecb984de07d00f24ebd9a6ffebc76ed9724828568ac9ede09f3be2fca98aadcdcbbb6be887f4eb0bf6acc704b9d05ff26ce8cc0a16f4bdd2bf7ae6c78e102f7a761f7d34b808750478d60bfbde9f230ac4fb95d2d003febef731d4b16346526fa519c6f4c140f0b86453ea6e97526f7478301ae91ea5f6a7c527c2154ed3c112fc335fb4cf505c3557a319d807c6a42506f23b384db8b5c9507ba2f1e5a5b6c2b9a0e0591ea58078ef65cae83a0a6f391716012ead4d7ca911320f94598d308410bf95c32f3111cfa544579d5724e43bbda9e1b9642b79a7b885d22b162d5bcec2b90472ceb9024905cbe2facdeee62cf9537901a6ea312d71b191828dbea5b80e0123a6b00b1f4dbbfe791b5149c8aa79f889c743f74dcb918aaefa4c5f08ce4515150316c918316a37e4e6be241daa2e64312dc08300d018b87fecfd6f5abe7b60dabf00adb782175192643dbb32567d168041e07fd41e8013a3f32ba8ceb9c29397c38999d9d39dd13186e589a4573b03fda517c2b149e98f79c2fccc09ad9dc7ff8155033fa0495797913cf16485bd39a3a463cddca68eca7ca9f96e746ad533a1f2662c15045ceeb1ea82b5a765e4de29e102d120eb7344026b35080e9c7fc598822f92ee005f7cdac2ad3d5dce3b086e3feb701081f02452502c97244af29e66bf4c5e8e13de97bfaf50845650059dbfee3cf381ceb7057ccd1fb87edb27ee5f6eccd3fa003c5acc54bc441578a600ec1b36306dd10aef7bea54cf3344fc5b488bcca8bafbae5b3af80325e16fd269fdd531dd54a9f7671a80b2a361df97c0cdc119f19a0f133c9bafff6f3277df1b7bcc9e0fbc39788ad85a50896aa95eef2b2f0f1f6f5292defa19d166e26bb3d3d7fecf77079ce3b4e723f32bc60d3936e8b0e44ab78e7f10e8060a173c77a5f4088e27401bf4ea98502e296ffacda035062d19bfe424e11b2df688d59998bdbb7b149e970bbc9306541cc86f8339a0d423555d4c49da8220a8c2c07f9acf3e45119b49e6a2e5ef303b9ced44f3b0ca0a845cd1a481ed4ca2e4312cc334a4c0b59569cee91a8c0c0878cd9bcbb5a30a88d456dc449806d5f7a56370f8844fb3c6dfaaf73afed4eb1b67b45807ee8daa20e1de10a5483537a5e690d02ca60b814799caafc4b5cc87e8d8b91432c978c4dc7f1ea70223350071cda3725a5a43abf978ccc5ee3c2081d7bca8a2971486cc33f2a95c0018fa45d53b22e4081ddd41ab04be157712291c48c99e9f864b532df3d58ca84d9c0d3af0aa113971b479ec86042c24bfaba117ccb77b843b932e3ee6a1c0b672c0ff0df8098514245807e7c612782f00f7031f3a5ceaded3f66925d05bbaeaeeaf0b5c43257165402bcd3edbe29feb7268f81f72780f50520e662d944a80b1f91f3d7b4619714da135a195ad08e88a2b0a8b8d8e8d99ac70f8f650fa7417e75c7d1b9c90c072778bd151762ee66b76af6213e90bcd5b11ece535527174a50072e0bf7d54f446ce0d2c4b3a48ba34ba179a1fb76987ebd947f2c398b35c57d7a2b21333ddf7591f38a98cd79a5a73d0f64c0f3b537abf5422c257bab1d64f5b969cb13222ad752657325de527e2d714c44abcd8fc7bfe4e1e3b3f1c9fd5f837221fa62f13f84505380fbfd33ce6aa4a00198c7993ce7511bcb2fd4078590dc0e600f73b637806ad46c970209059e47331d25a7094d15c370fac4d1802a6154feaac8ac9c246bc8fc8548afa28736e062597e26a9980529411fd96790fb445b3277cf5d71a450a63ed289d168a5d59d484df6ac555324d5e272db1617797bb4ad094de1fe2ccedbd818192dd3b721337548a0675a4b18b11a025620e7e456a0b2e55becbaf04858730ea5e0a5805d14de07867bd0aa521b769a0a9d1b3b326f25b5315e9b046f8b3d187748918dd910c075aae6e553e7b873675ca69d57f8e928944802491b8218372590d080960c8873274159033258ea958cb47ffdff7af076c6f99e8d77bd036f05e3819bdc5a9b2e952dcac2c9f9b6304ebbb4eef00c130cad94a71fd72ce246cf0e98426e417718d46352425faea3c5c2af5602033974581846800e701f761efdd6434f2034e7dbc4f22e77fa6880b0e50793fa8eda8ebc1b29000502cd94142d891341d380abf50c0624b8c140d9a2feecf2ba7a076873d92b1616d2c40397c2e090801acbc5e299b554f5b1ab73270f7a89d0d488d179a3c117fcbd3e4b60360662677b47bdcc2545087f00875aaecac5233e76b22f4b1ea179f8a21dd11535c10eff89debe7b5b6b8ee24aeefc5ac7638515a1725ca804e3395429704a001f5bc004f810135a18f9c338c013721db3c1d18b88362fefa060b442e0dedba19e4ad27b6b87b3d677af8508b5370974c142266c950421797907f0a6342b40fde2164034c2aaac0e796290a26d60603cedf7da155b6ce728356c33276725ea092d3f855774f78c068020e254df78744d6926a72fe76c361dd37743883c6b0a0024ccdc504ff1ded81aecfb5067b4883d260cebada5d6792e8182c0fbdd5719d9a0e596dee31991afdc37d8025c424382000398f97bb003c08d2bc83a2863582e2b3358f163bfc14128f21c1ec4249923026e46953f391d781aeeb31e954f121f63fae5bbe1750a4634443d81f619a4de55989a51ed10feb3e97b69d15242f8605bca1427c91dc1f299a876efb9a6ad288cedcf49d60355167a749615d878b1525030ff19f78f8ec3a1a18c91e67cf60426d75f0574ecb2ff6365d228b77446695f185b314f00077a4629a7e20a355307fa33278e2e2022b8137d532e7879e92278f65440e73af236e959567315853ec69258ce9d593f40f505b91075fe4d968408857f7dd7d4586da8543705e71e7b297683afc732eff8d02f97520afc7fd2574c85aff71d96fa02582f069ff33953e5400caef9f56ed18e10c451dfcde20f32b4b521f4bec5ce3f81da2d91be93bc504d1a9d59b0bd3af14d8d7232de446ba1a582c324b70b9ab02192d57b5200678abf16a0f99a917d74c8d3bb5600dfd46c902e147883854c8fb4c01f23e58a073f6a592acd06544a49687d271eacee4e361d41f3a1e57a8908db08bc81327e5285123190757804ca004546147eab05da2bc1481a9be12e80e1eaeabb9de890512e141c4adcda1ba67cd74133e9cfe57358d8e110ef81ae20c7c366273f693fe4d4b43db83255e80d0319222305cba750a34086d4166a3eb71ba7be40a01f59ea1ee8ce78b7798590c835529f32f6bfd3cee6211c81df914112acd140cff6b18006ba4b08151fb15985c1970144a18c9c8caf498a6aff2393e8fa7461152dd02b544d5f248b81f9088acfda984a03e90d2e0b0351e8448d7573e57e530b131b84b9ba5f9be109ea18b8c386d8d7b6a4659508c43e5e1629ce31e2e4132c447a3e25fb9c29c1d3a757af7d196c376084439f76559a88ddc73df273060d0eb8ab22f2ef56126b2d3d1f28b651d5203c92b794b6737f141c102e152b7993d855104d945b60f857a98e5b0d315815b1b0675e8e92e115650222c287365b66d3e36b7689d39ef78534f9a45d867a33fe855fcae6416188886cd5986a596e193a95ffd4817ee02383f58124c64f28ac63a52f4bf7d2657e0de6926b65d4712fa5285653f0d24b834273fb10ead6ca2ecfc44aef6d5d209ac00e38b263d175f166b779fcf5311d07e3ba0bddbd26f81e89a5593950b8f5a6a186516bc7f454bc59ae580fb47b742783a1936371a48c844c1954a2b33de432346ee9df02093d09bfc0ce644463f3446a569a985aba4aa8da64bae4c2a30776aca301db3d2704ffc7b9df90cd99bd0a974ef169c41b636a2667c588625eae8fa1309bbd5f92ba12c8e7aa375f3a226d7e3d5e01a86477edac9b848dcd9213525fd42d44339742844946a06ec0d7e60810b350e6ae0614dc060f0de9e1a1f8d73cf92e7c298236faf017658e9bbf082b773b493876fae48af616f1ff4011696d7a993db455c2b5dfbf516a5a6c56a48b2d1534fdac56b4f6abf398646f9764fc6adefc8abfabaf88d5d11dfaad81efc81333dcf396df3b84c053a37a67e7d60f745da3f6918512301e615d677986a0b4e8be5d7ee32a91491a0b0355534cb8e36fd3d5bfe8a4509f338da159c8228fc6af7308f2738e890a3ec82452d34e9648f9a612284341e577e9c27d6b7f5d330e3facfeac3814edd2e8c0868fcddc1aa27645156abf17dc1cd9d61f92c4ed483ae172976e04f50b1911a046f2c4736d767dbb73aad16a6be3dcfadc301d1e7aa4eac66f83cad4498f60262fff88ad29c82b42d8236935c08e83aad84628b1ee65882b36c95cb2a4cf5a2e3894383bd8131a012e8d0b26da475c91d0e8d80191e3e0e63aef00cddaa9b6adb98ef5182e2e6e580e19dd8d5d6f5a78b94c4fc75ce1d98f6281397563e0bd065ffbbadd48a337f1a25f40b7689344701c385133fa2008b6690020647cb3e6d3563cdebebaeec6a8f789483ed015c23c8866d3bdfe6ae90c81dc6ac25d12ee9f8f4558b95a5e3fbb6979e3db304520d0e6d08f842bfd4d81775214fa5f7ecad001a2e020851281d77f43760f9c6a88490d15e071eb6a43f84fe5061d8689f90268db23f0f663a4dac6b4d18e795a640658a1dfe82b47f9515c561eb29b7536f3b2debac9005cebfc5c7ef38d7b90b5b106388ad0940793c7b368a8549efe2a638698e316a8769cf129a020e21ae9eb80bb9e666330c4e86122fd0baaea76ed736dc94959dcab50c80bf1b82529830dd8bbe71d606931b7c75fc03c0e89335d42a2005f8156806689f119b050c78ed05c5f4d2c173f5ffbdc811a4d43e69422e46c9b00e7c9f289f6cc94b07abc31e15402ea81e53e1d7b87d7dafab7a3eaa1f53bffc6b35a0f397cacfeea0d01e7d4001137f13da3011a73417a40fb6b6d7c2570b467f12a731cfd7f5085d10a7c9824e4c46135fc13a0063a3c9e14659e74731a641abd82b23c553b31d700bf07e6e05853cda0845e25318ff0c922257d4c6eeaa9c9574e328317e7894636a9ebf58e40c9f2682727fba119809d1f9846915f22ec170d43ce9a089ef7cdfc16686e607b86a9dd289640d99f7b12ccb34f8119a3186e2265c920861946df43494f4884bc799ba73d01290490fa184477c8baf40a68389eba85776d25c3ee9358ed4ad9ba4cd4e2f994d7ed933b5813a0d7f93e8eba21c47a317d3116188d01588bbf9dd6cc72c011729395aa979d40931c7056f8ad48f438bf0332bb9acc9897439c0edbb51cab21f740c353a60900b78fe105dd556c2ee81ed1c6201f6be1540f2176c4ea7e210ddab854043074d6eabdf253358849bc9402a552b1b7363d85915c69e217d370e6793daf980794cdd41ae2e101c1ac739e9f43d5528535086d5210a843ed36da9a5ba5c525179f9408f6df2f8023b5edcc62299d4a981817835cf69cd860d847de930cbcc4bcfa2cf10e4ca73e9b629ead7c575f607d310d9ba99c3b485a1d2c54b005dc28121389520b2690810386d37121dd9804687e35338c197a4ecaa0e307ff7928384fe29ad508110d0544897d2dac4c391d7e2ff33e8ea4aacc13e06fc46a08fa7cde4e42093221970f246d45881a07c0ed5e5f7ed3d99cf394ab43363d95e514c6f0fc6b003ac90fbfc483c3bb1d7ddb04e0f09d865aa2ccf1c3383293dc7a222241e6e2a66e44e092c7763eae293559157205c71fb4ddb01821ddf15f3ce8c3270e5627540d7d661ffb65d8b5803262ceb52959921ec7ab3c201cad3550fe68e867eb1c6e73bf429d72d4801001c5962d5e7fbd4b3e610073cb714bccaddb06adf099f002fe221726290748673ec5138e4f59a9a93c2b5f52f626d0cf6981546d0ea37abfde649821069ffcb5bfef62b616f30651a44901afc2ec76c2367fa737bd8e3493ef3987627132979623244deef3802aabad8c2da73a36bea6a805608cfb3fafac525ee8581f31dfd2c76e848f053a12b8113a4fe66403b24513333cefc299d4c36f8778735825326e7d58be074e639c32a99544330f9b195b1937d01e7f7735d86b3f170ea5c7a77708791ef062c64e47293634d2e0f7117140871314769b94a441f649a17610d01b21c6f30639e391d02e1980106e390bb3dfe837a69cdb0a954166d5a0e8492c801941f9cc49f4ed76845e36764a8d4ca665ed791d9a567b8a064834d43901e5f58236834349af4b9ce1e6b8540ba822859c86c42c546f552a21d4433d66a6704503419abb61bb036b7daeba6f4a86cf7c7b0bc329aa2c217a690e15a25e1c1f7d4713a429883c527bc5fcf8d3de63754d636f4406b037ee55ab56f537e8936ab02324382e592adbbf1850382f7ea2e4ddb9bc3fa30067c944996fb00c7766419089cf89d586bc711617c44011b968958e35f1b3274a1c57e0cdb631882bc40610a850c75e86bec80a0577c15ddd230e00a85ce2be799f38574ee84b58b84447f42fa51185bd163921c442a403cbf9492fdfff1d3ff7eb99a6f23b96affc4c6ef7ef662e919517c3e9199633e8a8946fb5b830e696407efd6d43043d2979433a0c5d58a40f7220ef5bbe0d95cf029f9014b03068e5a4bc1f193c98799fe76fe6f3e85d5951046f84989263471c29bc6c316aa1d0e6be37b7b9babff86b93b6901a86d1f31752a6e48ea3c41b41b93596fa311aad43048f000cd0890d85ac5fe646519aaa3f26bc2576f85474a86d1f530c5615d941e46dd598e5e941257141bb8102867f9a1c001ff377231d2b6855aedf42c28fd07dee9e8835bc6f82a055b16ebf7b93e8fcca8c64846b6469819a82d32befc177a07a373f87db570b1b439b3af3a9ffe0dbb97461d3375b7e48b588fffad8a3f47ccf168a1ad9feabd912fd5f2164c06efe3d9cd475835875b3cf7671aac771321610849c789b650c15bbea1517b9c31c507f01e7e50179a4686ac7bff4c393b3ad8390d33cba4bd4469c09de26db8de30ff6aecaf416606324d2fdd532225e24cfc9aae3dc141747c93a7255b08ada3853d1bd84b8f6906d69e5dbcfe37503fe8a78943e49a6e455b4eb0803a149ac61369888d10db310fcebcb9d2f9f929ac040a0e3a3dcf6d0fc9afcee6023e0f358718df02aad24423cafafaf45ffa7e0382498d9e822507b48cbbda3253e32b3a62c97c08613794dfe82634b356adcb9a0b56e61e6ce153354c2ec9fa4c25579e6a13c1dd6f0f0ae34f783af756501c88cc324cc7b88d87879842b3853a774532e62be3e5fd34b3a91b857806463c5dce29e90a597590029470aae21bd4a629b0f26d7c9b37cc10a5f96050c9ba918b7664e32720632fe336aeb0c1f1869378c3978b7ec1535dae769fde7e4d60f1d30a7097865f26d8e2c0ca1e255800d1a6f683b4c738f06c5a8809bc68fc70866d0ca4feb7987ac1f035d6e6787e391a79aa7286dbffec072eba4d05c07ddc54fff7fa6afae9e65fb237475db5cea11976f6bef851ed1155ae697b1b7d212dc79c4de87cfa2c3934ea60815dddde3dc72e1f70f1d1045aa3e25966b8806ac1a67e25e9c2b23afcaf3994d001dd5a765d858794e3270ac65dee0eae6c4e041017bbb073184f759a36bd823792760d8b453547c791a9dbebb98b2a48c3175ba22ac01074e0079bfe037df98447363a7d2d99233e83849671673a5f85243da427b9091c600811b3a6667ff2e1345a90f334f54a7461d5db4d3a8569c1c4f9b0f58183728361ceec93ec741a178a18e32d9885e762d83830674359722154c874d95a9d3b4ccdde5717af3514d637ebf39191d16adca98e9b095c02cc9e0ff2550aa02cac4675212116b398dfb60d4642f0bb4b07a89c08f724e5adb400bb95e98adfcff12e8c2476ce861cb7a22b27200a4146dea2728e9819a5d2614d331fcbd7b4f242625adaac6204a4713fd9d56a3f359a9451626477ca6f7ec428688b3b03d9147d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>写给STico</category>
        <category>2022</category>
      </categories>
      <tags>
        <tag>personal</tag>
      </tags>
  </entry>
</search>
