---
title: 操作系统-作业一
date: 2022-04-22 23:00:24
tags:
- 操作系统
categories:
- 操作系统
- 作业
---

一般操作系统中，进程的每个段内部地址均连续，但段与段的相对次序可能不同。
用C/C++语言写一个小程序，探测一个操作系统中进程的各段的相对位置。
(输出次序即可)

截至日期：2022.4.14

<!--more-->

```cpp
#include <iostream>
#include <stdlib.h>
#include <iomanip>
#include <algorithm>
using namespace std;

const int       g_A = 1;    //代码段， 常量
int             g_B = 2;	//数据段， 全局变量
static int      g_C;		//BSS段， 未初始化全局静态变量

struct AddStruct
{
public:
    string name;
    long long add;
};

bool Cmpare(const AddStruct& a, const AddStruct& b)//const必须加,不然会错 当return的是ture时, a先输出, 所以示例中是升序
{
    return a.add < b.add;
}

int main(int argc, char const* argv[]) 	//栈，函数参数
{
    int local_A;					    //栈，局部变量
    static int local_B = 4;			    //数据段，局部静态变量
    static int local_C;				    //BSS段，未初始化局部静态变量

    char* p2 = "123456";			    //“123456”在代码段，
                                        //字符串常量， P2在栈上
    char* g_p1 = (char*)malloc(100);	    //申请的10字节空间在堆上

    AddStruct MyStruct[5];
    MyStruct[0].name = "Code";
    MyStruct[0].add = reinterpret_cast <long long>(&main);

    MyStruct[1].name = "Data";
    MyStruct[1].add = reinterpret_cast <long long>(&g_B);

    MyStruct[2].name = "BSS";
    MyStruct[2].add = reinterpret_cast <long long>(&g_C);

    MyStruct[3].name = "Stack";
    MyStruct[3].add = reinterpret_cast <long long>(p2);

    MyStruct[4].name = "Heap";
    MyStruct[4].add = reinterpret_cast <long long>(&g_p1);

    int i = 0;    
    sort(MyStruct, MyStruct+ 5, Cmpare);
    
    for (i = 0; i < 5; i++)
    {
        cout << setw(6)<< MyStruct[i].name << "Segment 的 address 为: " << MyStruct[i].add << endl;
    }
    
    return 0;
}
```

